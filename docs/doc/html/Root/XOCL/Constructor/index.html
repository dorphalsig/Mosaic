<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<TITLE>
Constructor
</TITLE>
</HEAD>
<FONT SIZE="+2"><B>Constructor</B></FONT><BR><BR><HR>
<FONT SIZE="+1"><B>Overview</B></FONT><BR>
<P>

      A constructor describes how to initialise a newly created instance of
      a class. Each class may define a number of constructors that are used
      when an instance of the class is sent an 'init/1' message. The constructor
      is a sequence of attribute names and an optional body. When an instance
      is initialised, the matching constructor is selected from the class.
      A constructor matches the initialisation arguments when it defines the
      same number of attribute names as the length of the initialization 
      arguments. The effect of using the selected constructor is to set
      the slots with the appropriate names in the constructor from the 
      initialization arguments and then to perform the body of the constructor.
      If defined, the body of the constructor must return 'self'. A constructor
      may optionally specify that it is a template for transforming an object
      into a string, it does so by including the optional modifier '!' after
      the sequence of names. If present, the body of the constructor is evaluated
      in a scope where the names of the object slots specified in the name list are
      bound to the supplied values.
    
<BR><HR><BR>
<B>Parents</B>
<A HREF="../../../Root/XOCL/Sugar/index.html">Sugar</A>
,<A HREF="../../../Root/XCore/Performable/index.html">Performable</A>
,<A HREF="../../../Root/XCore/Located/index.html">Located</A>
,<A HREF="../../../Root/XCore/Object/index.html">Object</A>
,<A HREF="../../../Root/XCore/Element/index.html">Element</A>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructors</B></FONT></TD>
</TR>
<TR><TD>Constructor(names,toString)</TD><TD>
        The names are a sequence of strings, toString defines whether or not
        the constructor produces a 'toString/0' operation. Other components 
        of a constructor are added using the 'add/1' operation.
      </TD></TR>
<TR><TD>Constructor(names,toString,doc,body)</TD><TD>
        This constructor is used to initialise all components and to define
        the toString operation.
      </TD></TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=3><FONT SIZE="+2">
<B>Attributes</B></FONT></TD>
</TR>
<TR><TD><B>body</B></TD><TD><A HREF="../../../Root/XCore/Performable/index.html">Performable<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>doc</B></TD><TD><A HREF="../../../Root/XCore/Performable/index.html">Performable<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>names</B></TD><TD><A HREF="../../../Root/XCore/String/index.html">Seq(String)<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>toString</B></TD><TD><A HREF="../../../Root/XCore/Boolean/index.html">Boolean<A></TD><TD>No Documentation Specified</TD></TR>
<TR>
<TD COLSPAN=3>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../Root/XCore/Performable/index.html">Performable</A>: endLine, line. <BR><B>From</B> <A HREF="../../../Root/XCore/Located/index.html">Located</A>: charEnd, charStart. <BR><B>From</B> <A HREF="../../../Root/XCore/Element/index.html">Element</A>: roleFiller. <BR></FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="2" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Operations</B></FONT></TD>
</TR>
<TR><TD><B><a href="#add">add</a>(element:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
        Elements can be added to a constructor. This allows sub-classes
        of constructor to add new features if required. The basic constructor
        can receive documentation expressions and body expressions.
      </TD></TR>
<TR><TD><B><a href="#bodyOp">bodyOp</a>():<A HREF="../../../Root/XCore/Performable/index.html">Performable<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#desugar">desugar</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
        A constructor expressions is sugar for the instantiation of
        the XCore::Constructor class. Note that the documentation
        expression may be null if it has not been initialised. All
        of the constructor names are placed in scope for the constructor
        operation (careful since this will mean that self.NAME <> NAME
        in the constructor body.
      </TD></TR>
<TR><TD><B><a href="#namesToString">namesToString</a>(names:<A HREF="../../../Root/XCore/String/index.html">Seq(String)<A>):<A HREF="../../../Root/XCore/Performable/index.html">Performable<A></B></TD><TD>
	    Produce a sequence of comma separated names as an expression
	    for the 'toString/0' operation produced by including '!' in the
	    constructor definition.
	  </TD></TR>
<TR><TD><B><a href="#operations">operations</a>(name:<A HREF="../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../Root/OCL/Operation/index.html">Seq(Operation)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#pprint">pprint</a>(out:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,indent:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
        Write out the text of the constructor definition expression
        to the supplied output channel at the given indent.
      </TD></TR>
<TR><TD><B><a href="#toString">toString</a>():<A HREF="../../../Root/XCore/String/index.html">String<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#toStringOperation">toStringOperation</a>(name:<A HREF="../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../Root/OCL/Operation/index.html">Seq(Operation)<A></B></TD><TD>
        Produce the 'toString/0' operation def that is added to a
        class definition if the '!' char is included in the
        constructor definition.
      </TD></TR>
<TR>
<TD COLSPAN=2>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../Root/XOCL/Sugar/index.html">Sugar</A>: FV, compile, desugar, eval, lift, maxLocals, typeExp. <BR><B>From</B> <A HREF="../../../Root/XCore/Performable/index.html">Performable</A>: FV, compile, endLine, eval, line, maxLocals, pprint, pprint, pprint, setEndLine, setLine. <BR><B>From</B> <A HREF="../../../Root/XCore/Object/index.html">Object</A>: addDaemon, addDiagramListener, addMissingSlot, addMultiDaemon, addPersistentDaemon, addStructuralFeature, allCompositeValues, allCompositeValuesAndSelf, allDaemonsWithId, allDaemonsWithTarget, applyMapping_client, calcChildrenSlots, changedOnDiagram, compositeValues, daemonNamed, daemonWithId, daemonWithIdAndTarget, daemons, daemonsActive, destroyDaemon, edit, fire, get, getAvailableMappings, getChildren, getChildrenSlots, getChildrenToolTips, getDiagramListenerNamed, getDiagramListeners, getProperties, getProperty, getStructuralFeatureNames, hasDaemonNamed, hasDaemonWithId, hasDaemonWithIdAndTarget, hasDaemonWithTarget, hasProperty, hasSlot, hasStructuralFeature, hotLoad, hotLoaded, ignoreBy, ignoreByAll, init, initSlots, machineInit, nodeEvent, observeBy, observeBy, observedBy, observedBy, oldEdit, orderSequence, orderSequence, propertyTarget, removeDaemon, removeDaemonNamed, removeDaemonsWithId, removeDaemonsWithTarget, removeDiagramListener, removeDiagramListeners, removeStructuralFeature, renameSlot, saveXTO, saveXTOFile, set, setDaemons, setDaemonsActive, setHotLoad, setProperty, showAndLayoutDiagram, showDiagram, slotDenied, slotMissing, slotMissing, slots, synchronise. <BR><B>From</B> <A HREF="../../../Root/XCore/Element/index.html">Element</A>: addTo, allHTMLEntries, allHTMLPackages, assignToGlobal, assignToGlobal, browse, browse_redirect, checkConstraints, copy, copyToClipboard, copyToClipboard_transaction, createDiagram, createDiagramType, createDiagramType, createDiagramType, createTool, cutToClipboard, cutToClipboard_transaction, deleteRecursive, deployXML, die, doc, doubleClick, edit, edit_redirect, equals, error, evaluateExpression, ferror, getChildren, getChildrenToolTips, getDefaultClipboardSource, getDefaultClipboardTarget, graphVizNode, hashCode, init, init, invokeOp, isDeleteProtected, isKindOf, isProtected, isReallyKindOf, isTypeOf, isViewProtected, isWithinNameSpace, labelString, legalNameChangeCheck, legalSlotChangeCheck, legalSlotChangeCheck, lift, nameString, noOperationFound, oclIsKindOf, oclIsTypeOf, of, oldShowDiagram, pasteFromClipboard, populateGraphViz, pprint, pprint, pprint, pprintln, print, println, removeDaemon, removeDaemon, save, save2, selectDiagram, selectModelBrowserNode, send, setDelegation, setOf, setRoleFillerDialog, showAndLayoutDiagram, showDiagram, showModelBrowserNode, slotAffectsLabel, systemId, toHTML, toSVG, toSnapshot, toSnapshot, toString, toType, writeHTML, writeHTML, writeHTMLAllEntries, writeHTMLAllPackages, writeHTMLIndex, writeHTMLOverview, writeXML, writeXMLFile, yield. <BR><TR><TD COLSPAN=2><a name="add"/><FONT FACE="Courier" SIZE="1">@Operation&#160;add(element&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;@TypeCase(element)<br>&#160;&#160;&#160;&#160;XOCL::Doc&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;self.doc&#160;:=&#160;element<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;Performable&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;self.body&#160;:=&#160;element<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;Seq(Element)&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;@For&#160;e&#160;in&#160;element&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.add(e)<br>&#160;&#160;&#160;&#160;&#160;&#160;end;<br>&#160;&#160;&#160;&#160;&#160;&#160;self<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="bodyOp"/><FONT FACE="Courier" SIZE="1">@Operation&#160;bodyOp():Performable<br>&#160;&#160;if&#160;body&#160;=&#160;null<br>&#160;&#160;then&#160;[|&#160;null&#160;|]<br>&#160;&#160;else&#160;let&#160;bodyInScope&#160;=&#160;names-&gt;iterate(name&#160;exp&#160;=&#160;body&#160;|<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;[|&#160;let&#160;Drop(Var(name,91))&#160;=&#160;self.&lt;name&gt;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;&lt;exp&gt;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;|])<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;[|&#160;@Operation&#160;anonymous():XCore::Element<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&lt;bodyInScope&gt;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;|]<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="desugar"/><FONT FACE="Courier" SIZE="1">@Operation&#160;desugar():XCore::Element<br>&#160;&#160;let&#160;nameExps&#160;=&#160;SetExp("Seq",names-&gt;collect(n&#160;|<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;StrExp(n)));<br>&#160;&#160;&#160;&#160;&#160;&#160;docExp&#160;=&#160;if&#160;doc&#160;=&#160;null<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;[|&#160;noDoc()&#160;|]<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;doc<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;;<br>&#160;&#160;&#160;&#160;&#160;&#160;sourceExp&#160;=&#160;if&#160;body&#160;=&#160;null<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;[|&#160;null&#160;|]<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;StrExp(body.pprint())<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;in&#160;[|&#160;XCore::Constructor(&lt;nameExps&gt;,&lt;self.bodyOp()&gt;,&lt;docExp&gt;,&lt;sourceExp&gt;,&lt;toString.lift()&gt;)&#160;|]<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="namesToString"/><FONT FACE="Courier" SIZE="1">@Operation&#160;namesToString(names&#160;:&#160;Seq(String)):Performable<br>&#160;&#160;if&#160;names-&gt;isEmpty<br>&#160;&#160;then&#160;[|&#160;""&#160;|]<br>&#160;&#160;else&#160;let&#160;name&#160;=&#160;names-&gt;head;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rest&#160;=&#160;names-&gt;tail<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;if&#160;rest-&gt;isEmpty<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;[|&#160;if&#160;self.hasSlot(&lt;name.lift()&gt;)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;self.&lt;name&gt;.toString()<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;&lt;name.lift()&gt;&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;&#160;|]<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;[|&#160;if&#160;self.hasSlot(&lt;name.lift()&gt;)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;self.&lt;name&gt;.toString()<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;&lt;name.lift()&gt;&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;&#160;+&#160;","&#160;+&#160;&lt;self.namesToString(rest)&gt;&#160;|]<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="operations"/><FONT FACE="Courier" SIZE="1">@Operation&#160;operations(name&#160;:&#160;String):Seq(Operation)<br>&#160;&#160;self.toStringOperation(name)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="pprint"/><FONT FACE="Courier" SIZE="1">@Operation&#160;pprint(out&#160;:&#160;XCore::Element,indent&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;format(out,"@Constructor(~{,~;~S~})~[&#160;!~;~]",Seq{names,toString});<br>&#160;&#160;if&#160;doc&#160;&lt;&gt;&#160;null<br>&#160;&#160;then&#160;<br>&#160;&#160;&#160;&#160;format(out,":~%~V",Seq{indent&#160;+&#160;4});<br>&#160;&#160;&#160;&#160;doc.pprint(out,indent&#160;+&#160;2);<br>&#160;&#160;&#160;&#160;format(out,"~%~V",Seq{indent&#160;+&#160;2})<br>&#160;&#160;else&#160;format(out,"~%~V",Seq{indent&#160;+&#160;2})<br>&#160;&#160;end&#160;;<br>&#160;&#160;body.pprint(out,indent&#160;+&#160;2);<br>&#160;&#160;format(out,"~%~Vend",Seq{indent})<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="toString"/><FONT FACE="Courier" SIZE="1">@Operation&#160;toString():String<br>&#160;&#160;try<br>&#160;&#160;&#160;&#160;self.of().name.toString()&#160;+&#160;"("&#160;+&#160;if&#160;self.hasSlot("names")<br>&#160;&#160;&#160;&#160;then&#160;self.names.toString()<br>&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;"names"&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;end&#160;&#160;+&#160;","&#160;+&#160;if&#160;self.hasSlot("toString")<br>&#160;&#160;&#160;&#160;then&#160;self.toString.toString()<br>&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;"toString"&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;end&#160;&#160;+&#160;","&#160;+&#160;if&#160;self.hasSlot("doc")<br>&#160;&#160;&#160;&#160;then&#160;self.doc.toString()<br>&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;"doc"&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;end&#160;&#160;+&#160;","&#160;+&#160;if&#160;self.hasSlot("body")<br>&#160;&#160;&#160;&#160;then&#160;self.body.toString()<br>&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;"body"&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;end&#160;&#160;+&#160;")"<br>&#160;&#160;catch(exception)<br>&#160;&#160;&#160;&#160;self.of().name&#160;+&#160;"(Constructor&#160;Error!)"<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="toStringOperation"/><FONT FACE="Courier" SIZE="1">@Operation&#160;toStringOperation(name&#160;:&#160;String):Seq(Operation)<br>&#160;&#160;if&#160;toString<br>&#160;&#160;then&#160;Seq{[|&#160;@Operation&#160;toString():String<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.of().name.toString()&#160;+&#160;"("&#160;+&#160;&lt;self.namesToString(names)&gt;&#160;+&#160;")"<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch(exception)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.of().name&#160;+&#160;"(Constructor&#160;Error!)"<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;|]}<br>&#160;&#160;else&#160;Seq{}<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
</FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Grammar</B></FONT></TD>
</TR>
<TD><PRE>
Constructor ::=  '('   AttNames   = names   ')'   ToString   = toString   Constructor-Star0   = body   'end'  { Constructor(names,toString).add(body) }.
SetCmpExp ::=  LinePos   = l   '{'   CommaSepExps   = es   '}'   !  { SetExp(l,"Set",es) } |  LinePos   = l   '{'   Exp   = e   '|'   CmpClause   = c   SetCmpExp-Star0   = cs   '}'  { Comprehensions::Cmp("Set",e,Seq{c | cs}) }.
ToString ::=  '!'  { true } | { false }.
AddPattern-Dis0 ::=  '+'   AddPattern   = p2  { Addp(p1,p2) } |  <VarRef 26d457> .
AttName ::=  Name  |  Str .
BindValue ::=  OptType   = type   '='   SimpleExp   = value  { ValueBinding(name,type,value) }.
Constructor-Star0 ::=  Exp   = $head   Constructor-Star0   = $tail   Cons  |  Nil .
Def ::=  'context'   Def-Dis0   = isForward   ImportPath   = path   PushChar   Exp   PopChar   = exp  { ContextDef(path,exp,isForward) }.
AttNames ::=  AttName   = name   AttNames-Star0   = names   <Pair 497a3f>  |  Seq{} .
LocalParserImport-Star0 ::=  '::'   Name   = $head   LocalParserImport-Star0   = $tail   Cons  |  Nil .
AttNames-Star0 ::=  ','   AttName   = $head   AttNames-Star0   = $tail   Cons  |  Nil .
NonEmptySeqTail ::=  PushChar   Expr   PopChar   = e   PairOrElements .
Keywordp ::=  Name   = name   Keywordp-Star0   = names   '['   Keyps   = keys   ']'  { Keywordp(name,names,keys) }.
Import ::=  PushChar   'import'   ImportPath   = path   ';'  { Import(path) }  PopChar .
SeqCmpExp-Star0 ::=  ','   CmpClause   = $head   SeqCmpExp-Star0   = $tail   Cons  |  Nil .
Varp ::=  AName   = name   Varp-Dis0   = pattern   Varp-Dis1   = type  { Varp(name,pattern,type) }.
EvaluationUnit ::=  EvaluationUnit-Star0   EvaluationUnit-Star1   = imports   EvaluationUnit-Star2   = exps   EOF  { Evaluator::EvaluationUnit(imports,exps) }.
IfTail ::=  'else'   PushChar   Expr   PopChar   'end'  |  LinePos   = l   'elseif'   PushChar   Expr   PopChar   = e1   'then'   PushChar   Expr   PopChar   = e2   IfTail   = e3  { If(l,e1,e2,e3) } |  'end'  { BoolExp(false) }.
Atom ::=  PushChar   VarExp   PopChar   !  |  PushChar   Self   PopChar   !  |  PushChar   StrExp   PopChar   !  |  PushChar   IntExp   PopChar   !  |  PushChar   IfExp   PopChar   !  |  PushChar   BoolExp   PopChar   !  |  PushChar   LetExp   PopChar   !  |  PushChar   CollExp   PopChar   !  |  Parentheses  |  PushChar   Drop   PopChar  |  PushChar   Lift   PopChar  |  PushChar   Throw   PopChar  |  PushChar   Try   PopChar  |  PushChar   ImportIn   PopChar  |  PushChar   FloatExp   PopChar  |  PushChar   LocalParserImport   PopChar  |  PushChar   AtExp   PopChar .
AddPattern ::=  AtomicPattern   = p1   AddPattern-Dis0 .
EvaluationUnit-Star2-Dis0 ::=  Def  |  TopLevelExp .
Keyps-Star0 ::=  ','   Keyp   = $head   Keyps-Star0   = $tail   Cons  |  Nil .
Syntaxp ::=  '[|'   PushChar   Exp   PopChar   = e   '|]'  { Syntaxp(e) }.
VarExp ::=  Name   = name   LinePos   = l  { Var(name,l) }.
CollMessage ::=  '('   CommaSepExps   = as   ')'  { CollExp(c,n,as) }.
BindingList ::=  PushChar   Binding   PopChar   = binding   BindingList-Star0   = bindings   <Pair 17eb14> .
PathExp ::=  PushChar   Atom   PopChar   = atom   PathExp-Dis0 .
Objectp ::=  Name   = name   Objectp-Star0   = names   '('   Patterns   = slots   ')'  { Objectp(name,names,slots) }.
Parentheses ::=  '('   PushChar   Expr   PopChar   = e   ')'  { Parentheses(e) }.
SeqCmpExp ::=  LinePos   = l   '['   CommaSepExps   = es   ']'   !  { SetExp(l,"Seq",es) } |  LinePos   = l   '['   Exp   = e   '|'   CmpClause   = c   SeqCmpExp-Star0   = cs   ']'  { Comprehensions::Cmp(e,Seq{c | cs}) }.
CollOp ::=  CollMessage  |  Collect  |  Iterate  | { CollExp(c,n,Seq{}) }.
Constp ::=  Intp  |  Strp  |  Boolp  |  Expp .
Throw ::=  LinePos   = l   'throw'   PushChar   SimpleExp   PopChar   = value  { Throw(l,value) }.
SeqExp ::=  LinePos   = l   'Seq{'   SeqExp-Dis0 .
EvaluationUnit-Star2 ::=  EvaluationUnit-Star2-Dis0   = $head   EvaluationUnit-Star2   = $tail   Cons  |  Nil .
ArgsTail-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   ArgsTail-Star0   = $tail   Cons  |  Nil .
ArrowTail ::=  Name   = n   CollOp   = x   Arrow .
BindFunArgsTail ::=  Pattern   = p   BindFunArgsTail-Star0   = ps   ')'   <Pair 36c016>  |  ')'   Seq{} .
Exp ::=  PushChar   Expr   PopChar   = e   !  { resolve(order(e)) }.
Drop ::=  '<'   DropExp   = e   '>'  { Drop(resolve(order(e))) } |  '<|'   Pattern   = p   '|>'  { DropPattern(p) }.
SetCmpExp-Star0 ::=  ','   CmpClause   = $head   SetCmpExp-Star0   = $tail   Cons  |  Nil .
Objectp-Star0 ::=  '::'   Name   = $head   Objectp-Star0   = $tail   Cons  |  Nil .
KeyArg ::=  Name   = name   '='   PushChar   Expr   PopChar   = exp  { KeyArg(name,exp) }.
LogicalExp ::=  PushChar   SimpleExp   PopChar   = e  { resolve(order(e)) }.
Keyps ::=  Keyp   = key   Keyps-Star0   = keys   <Pair 2ed48a>  |  Seq{} .
ImportPath ::=  Name   = n   ImportPath-Star0   = ns   <Pair 3eada7> .
Patterns-Star0 ::=  ','   Pattern   = $head   Patterns-Star0   = $tail   Cons  |  Nil .
Varp-Dis0 ::=  '='   PushChar   Pattern   PopChar  |  null .
EmptySeqTail ::=  '}'  { SetExp(l,"Seq",Seq{}) }.
IfExp ::=  LinePos   = l   'if'   PushChar   Expr   PopChar   = e1   'then'   PushChar   Expr   PopChar   = e2   IfTail   = e3  { If(l,e1,e2,e3) }.
AtExp ::=  LinePos   = l   '@'   PushChar  At  PopChar   = e  { e.setLine(l) }.
AName ::=  Name   !  |  Drop .
Def-Dis0 ::=  '!'  { true } | { false }.
Keywordp-Star0 ::=  '::'   Name   = $head   Keywordp-Star0   = $tail   Cons  |  Nil .
Strp ::=  Str   = s  { Constp(StrExp(s)) }.
Try ::=  LinePos   = l   'try'   PushChar   Expr   PopChar   = body   'catch'   '('   Name   = name   ')'   PushChar   Expr   PopChar   = handler   'end'  { Try(l,body,name,handler) }.
Collect ::=  '('   AName   = v   '|'   PushChar   Expr   PopChar   = e   ')'  { IterExp(c,n,v,e) }.
Bindings ::=  BindingList  |  Drop .
Pattern ::=  AddPattern   = p   Pattern-Star0   = es  { es->iterate(e s = p |
  Includingp(s,e)) }  = p   PatternGuard .
Op ::=  BinOp   !  |  ';'   ; .
ParserImport ::=  'parserImport'   Name   = name   ParserImport-Star0   = names   ';'   <Pair 4597cc>  ImportAt { ParserImport(Seq{name} + names,null) }.
SetExp ::=  LinePos   = l   'Set{'   CommaSepExps   = es   '}'  { SetExp(l,"Set",es) }.
CollExp ::=  PushChar   SetExp   PopChar   !  |  PushChar   SeqExp   PopChar   !  |  PushChar   SetCmpExp   PopChar   !  |  PushChar   SeqCmpExp   PopChar   ! .
Consp ::=  Pairp  |  Seqp  |  Emptyp .
TopLevelExp ::=  PushChar   SimpleExp   PopChar   = s   ';'  { resolve(order(s)) }.
Seqp ::=  'Seq{'   Pattern   = head   SeqpTail   = tail  { Consp(head,tail) }.
EvaluationUnit-Star1 ::=  EImport   = $head   EvaluationUnit-Star1   = $tail   Cons  |  Nil .
BindFunArgsTail-Star0 ::=  ','   Pattern   = $head   BindFunArgsTail-Star0   = $tail   Cons  |  Nil .
ArgsTail ::=  ')'   Seq{}  |  PushChar   Expr   PopChar   = arg   ArgsTail-Star0   = args   ')'   <Pair 341906> .
BindFunArgs ::=  '('   BindFunArgsTail .
Expr ::=  'not'   PushChar   Expr   PopChar   = e  { Negate(e) } |  '-'   PushChar   SimpleExp   PopChar   = e  { BinExp(IntExp(0),"-",e) } |  PushChar   Apply   PopChar   = a   ExpTail .
DropExp ::=  'not'   DropExp   = e  { Negate(e) } |  PushChar   Apply   PopChar   = a   DropExpTail .
SeqExp-Dis0 ::=  EmptySeqTail  |  NonEmptySeqTail .
PairOrElements-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   PairOrElements-Star0   = $tail   Cons  |  Nil .
KeyArgs ::=  '['   KeyArgs-Dis0 .
LocalParserImport ::=  'parserImport'   Name   = name   LocalParserImport-Star0   = names   <Pair 5f19e7>  ImportAt  'in'   PushChar   Expr   PopChar   = e   'end'  { ParserImport(Seq{name | names},e) }.
Keyp ::=  Name   = name   '='   Pattern   = pattern  { Keyp(name,pattern) }.
ImportIn ::=  'import'   ImportPath   = path   'in'   PushChar   Exp   PopChar   = body   'end'  { ImportIn(path,body) }.
Pattern-Star0 ::=  PatternTail   = $head   Pattern-Star0   = $tail   Cons  |  Nil .
Varp-Dis1 ::=  ':'   PushChar   TypeExp   PopChar  | { NamedType() }.
Emptyp ::=  'Seq{'   '}'  { Constp(SetExp("Seq",Seq{})) } |  'Set{'   '}'  { Constp(SetExp("Set",Seq{})) }.
FloatExp ::=  LinePos   = l   Float   = f  { f.lift().line := l }.
AtomicPattern ::=  PushChar   Varp   PopChar  |  PushChar   Constp   PopChar  |  PushChar   Objectp   PopChar  |  PushChar   Consp   PopChar  |  PushChar   Keywordp   PopChar  |  PushChar   Syntaxp   PopChar  |  '('   PushChar   Pattern   PopChar   ')' .
Apply ::=  PushChar   Atom   PopChar   = a   ApplyTail   = e   Arrow .
CompilationUnit-Star0 ::=  ParserImport   = $head   CompilationUnit-Star0   = $tail   Cons  |  Nil .
KeyArgs-Dis0 ::=  ']'   Seq{}  |  KeyArg   = arg   KeyArgs-Dis0-Star0   = args   ']'   <Pair 341a71> .
StrExp ::=  LinePos   = l   Str   = e  { StrExp(l,e) }.
TypePath ::=  Name   = name   TypePath-Star0   = names  { Seq{name | names}->collect(n |
  Symbol(n)) }.
CommaSepExps ::=  PushChar   Expr   PopChar   = e   CommaSepExps-Star0   = es   <Pair 3b9768>  |  Seq{} .
BinOp ::=  '<'   <  |  '<='   <=  |  '>'   >  |  '>='   >=  |  '<>'   <>  |  '='   =  |  '::'   ::  |  ':='   :=  |  '.'   .  |  'and'   and  |  'andthen'   andthen  |  'implies'   implies  |  'or'   or  |  'orelse'   orelse  |  '+'   +  |  '-'   -  |  '*'   *  |  '/'   / .
PatternGuard ::=  'when'   PushChar   Exp   PopChar   = e  { Condp(p,e) } |  <VarRef 3925d2> .
OpType ::=  TypeArgs   = domains   '->'   PushChar   TypeExp   PopChar   = range  { OpType(domains,range) }.
Pairp ::=  'Seq{'   Pattern   = head   '|'   Pattern   = tail   '}'  { Consp(head,tail) }.
Self ::=  LinePos   = l   'self'  { Self(l) }.
CmpClause ::=  Name   = n   OptType   = t   '<-'   PushChar   Exp   PopChar   = e  { Comprehensions::Bind(n,t.toExp(),e) } |  '?'   PushChar   Exp   PopChar   = e  { Comprehensions::Filter(e) }.
CompilationBodyExps ::=  CompilationBody   = b   !   CompilationBodyExps   = bs   <Pair 3eaeb0>  |  Seq{} .
TopLevelCommand ::=  PushChar   SimpleExp   PopChar   = c   pState   = p  { p.consumeToken := false }  ';'  { resolve(order(c)) }.
SeqpTail ::=  ','   Pattern   = head   SeqpTail   = tail  { Consp(head,tail) } |  '}'  { Constp(SetExp("Seq",Seq{})) }.
EvaluationUnit-Star0 ::=  ParserImport   = $head   EvaluationUnit-Star0   = $tail   Cons  |  Nil .
BindingList-Star0 ::=  ';'   PushChar   Binding   PopChar   = $head   BindingList-Star0   = $tail   Cons  |  Nil .
Args ::=  '('   ArgsTail .
BindFun ::=  BindFunArgs   = args   OptType   = type   '='   PushChar   SimpleExp   PopChar   = value  { FunBinding(name,args,type,value) }.
ExpTail ::=  Op   = o   !   PushChar   Expr   PopChar   = e  { BinExp(a,o,e) } |  <VarRef 390d5c> .
DropExpTail ::=  DropOp   = o   !   DropExp   = e  { BinExp(a,o,e) } |  <VarRef 3b958a> .
TypeExp-Dis0 ::=  TypeArgs   = args  { ParametricType(path,args) } | { NamedType(path) }.
ParserImport-Star0 ::=  '::'   Name   = $head   ParserImport-Star0   = $tail   Cons  |  Nil .
Iterate ::=  '('   AName   = v1   AName   = v2   '='   PushChar   Expr   PopChar   = init   '|'   PushChar   Expr   PopChar   = body   ')'  { Iterate(c,v1,v2,init,body) }.
Lift ::=  LinePos   = l   '[|'   PushChar   Exp   PopChar   = e   '|]'  { Lift(l,e) }.
LetBody ::=  'in'   PushChar   Expr   PopChar   = body   <VarRef 480098>  |  PushChar   'then'   PushChar   Bindings   PopChar   = bindings   LetBody   = body  { Let(bindings,body) }  PopChar .
IntExp ::=  LinePos   = l   Int   = e  { IntExp(l,e) }.
PathExp-Dis0 ::=  '::'   AName   = name   PathExp-Dis0-Star0   = names  { Path(atom,Seq{name | names}) } |  <VarRef 341bbe> .
TypePath-Star0 ::=  '::'   Name   = $head   TypePath-Star0   = $tail   Cons  |  Nil .
EImport ::=  'import'   TopLevelExp   = exp  { Evaluator::Import(exp) }.
Expp ::=  '['   PushChar   Exp   PopChar   = exp   ']'  { Constp(exp) }.
Binding ::=  AName   = name   BindingTail .
ApplyTail ::=  Args   = args   !  { Apply(a,args) } |  KeyArgs   = args   !  { Instantiate(a,args) } |  <VarRef f0667> .
CompilationUnit-Star1 ::=  Import   = $head   CompilationUnit-Star1   = $tail   Cons  |  Nil .
KeyArgs-Dis0-Star0 ::=  ','   KeyArg   = $head   KeyArgs-Dis0-Star0   = $tail   Cons  |  Nil .
SimpleExpTail ::=  BinOp   = o   !   PushChar   SimpleExp   PopChar   = e  { BinExp(a,o,e) } |  <VarRef f065f> .
TypeArgs ::=  '('   PushChar   TypeExp   PopChar   = arg   TypeArgs-Star0   = args   ')'   <Pair 3eaec4> .
CompilationUnit ::=  CompilationUnit-Star0   = parserImports   CompilationUnit-Star1   = imports   CompilationBodyExps   = exps   EOF   pState   = s  { CompilationUnit("",imports,exps,s.getSource(),parserImports) }.
BoolExp ::=  LinePos   = l   'true'  { BoolExp(l,true) } |  LinePos   = l   'false'  { BoolExp(l,false) }.
PatternTail ::=  '->'   Name   '('   Pattern   = p   ')'   <VarRef 438518> .
OptType ::=  ':'   PushChar   TypeExp   PopChar  | { NamedType() }.
PairOrElements ::=  '|'   PushChar   Expr   PopChar   = t   '}'  { ConsExp(e,t) } |  PairOrElements-Star0   = es   '}'  { SetExp(l,"Seq",Seq{e | es}) }.
Patterns ::=  Pattern   = head   Patterns-Star0   = tail   <Pair 5b7cc6>  |  Seq{} .
Boolp ::=  'true'  { Constp(BoolExp(true)) } |  'false'  { Constp(BoolExp(false)) }.
CompilationBody ::=  Def  |  TopLevelExp .
TypeExp ::=  TypePath   = path   TypeExp-Dis0  |  '['   PushChar   TypeExp   PopChar   = t   ']'  { ParametricType(Seq{"Seq"},Seq{t}) } |  '{'   PushChar   TypeExp   PopChar   = t   '}'  { ParametricType(Seq{"Set"},Seq{t}) } |  Drop  |  OpType .
SimpleExp ::=  'not'   PushChar   SimpleExp   PopChar   = e  { Negate(e) } |  '-'   PushChar   SimpleExp   PopChar   = e  { BinExp(IntExp(0),"-",e) } |  PushChar   Apply   PopChar   = a   SimpleExpTail .
ImportPath-Star0 ::=  '::'   Name   = $head   ImportPath-Star0   = $tail   Cons  |  Nil .
CommaSepExps-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   CommaSepExps-Star0   = $tail   Cons  |  Nil .
Arrow ::=  '->'   !   ArrowTail  |  <VarRef 26d54c> .
BindingTail ::=  BindFun  |  BindValue .
Exp1 ::=  PushChar   Exp   PopChar   EOF .
DropOp ::=  '<'   <  |  '<='   <=  |  '<>'   <>  |  '='   =  |  '::'   ::  |  ':='   :=  |  '.'   .  |  'and'   and  |  'andthen'   andthen  |  'implies'   implies  |  'or'   or  |  'orelse'   orelse  |  '+'   +  |  '-'   -  |  '*'   *  |  '/'   / .
TypeArgs-Star0 ::=  ','   PushChar   TypeExp   PopChar   = $head   TypeArgs-Star0   = $tail   Cons  |  Nil .
PathExp-Dis0-Star0 ::=  '::'   AName   = $head   PathExp-Dis0-Star0   = $tail   Cons  |  Nil .
Intp ::=  Int   = i  { Constp(IntExp(i)) }.
LetExp ::=  LinePos   = l   'let'   PushChar   Bindings   PopChar   = bindings   LetBody   = body   'end'  { Let(l,bindings,body) }.
</PRE></TD>
</TABLE>
</HTML>
