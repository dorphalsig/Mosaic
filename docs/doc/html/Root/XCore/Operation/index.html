<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<TITLE>
Operation
</TITLE>
</HEAD>
<FONT SIZE="+2"><B>Operation</B></FONT><BR><BR><HR>
<FONT SIZE="+1"><B>Overview</B></FONT><BR>
<P>

      Operation is the abstract super-class of all operations in XMF. An operation
      can be compiled or interpreted. All operations have parameters, a return type
      and a body. The body must be performable. An operation is invoked using 
      'invoke/2' where the first argument is the value of 'self' in the operation 
      body and the second argument is a sequence of parameter values.
    
<BR><HR><BR>
<B>Parents</B>
<A HREF="../../../Root/XCore/BehaviouralFeature/index.html">BehaviouralFeature</A>
,<A HREF="../../../Root/XCore/TypedElement/index.html">TypedElement</A>
,<A HREF="../../../Root/XCore/DocumentedElement/index.html">DocumentedElement</A>
,<A HREF="../../../Root/XCore/NamedElement/index.html">NamedElement</A>
,<A HREF="../../../Root/XCore/Contained/index.html">Contained</A>
,<A HREF="../../../Root/XCore/Object/index.html">Object</A>
,<A HREF="../../../Root/XCore/Element/index.html">Element</A>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructors</B></FONT></TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=3><FONT SIZE="+2">
<B>Attributes</B></FONT></TD>
</TR>
<TR>
<TD COLSPAN=3>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../Root/XCore/TypedElement/index.html">TypedElement</A>: type. <BR><B>From</B> <A HREF="../../../Root/XCore/DocumentedElement/index.html">DocumentedElement</A>: documentation. <BR><B>From</B> <A HREF="../../../Root/XCore/NamedElement/index.html">NamedElement</A>: name. <BR><B>From</B> <A HREF="../../../Root/XCore/Contained/index.html">Contained</A>: owner. <BR><B>From</B> <A HREF="../../../Root/XCore/Element/index.html">Element</A>: roleFiller. <BR></FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="2" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Operations</B></FONT></TD>
</TR>
<TR><TD><B><a href="#arity">arity</a>():<A HREF="../../../Root/XCore/Integer/index.html">Integer<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#break">break</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Adds a breakpoint to the receiver. When the receiver is
      called, execution halts and allows the user to investigate
      the current context.
    </TD></TR>
<TR><TD><B><a href="#breakFun">breakFun</a>(fun:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      This operation returns a function that can be invoked to
      enter a break point. When the break point returns the
      original operation is called.
    </TD></TR>
<TR><TD><B><a href="#calcChildrenSlots">calcChildrenSlots</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#deployJava">deployJava</a>(out:<A HREF="../../../Root/IO/OutputChannel/index.html">OutputChannel<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#dynamics">dynamics</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      The dynamics of an operation are the imported name spaces.
    </TD></TR>
<TR><TD><B><a href="#fork">fork</a>(name:<A HREF="../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#fork">fork</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#getDerivedValue">getDerivedValue</a>(cache:<A HREF="../../../Root/XCore/Table/index.html">Table<A>,this:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,args:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#globals">globals</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      The environment of freely referenced variables in the body
      of the operation. 
    </TD></TR>
<TR><TD><B><a href="#invoke">invoke</a>(target:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,args:<A HREF="../../../Root/XCore/Element/index.html">Seq(Element)<A>,supers:<A HREF="../../../Root/XCore/Operation/index.html">Seq(Operation)<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      An operation is performed by invoking it. The arguments are
      given as the target (the value of self) and the sequence of
      arguments required by the operation. Deal with var args here
      by turning any extra arguments into a single argument that is
      a sequence. The supers argument is used to supply the supers
      value allowing the run-super mechanism to restart the lookup.
    </TD></TR>
<TR><TD><B><a href="#invoke">invoke</a>(target:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,args:<A HREF="../../../Root/XCore/Element/index.html">Seq(Element)<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      An operation is performed by invoking it. The arguments are
      given as the target (the value of self) and the sequence of
      arguments required by the operation. Deal with var args here
      by turning any extra arguments into a single argument that is
      a sequence.
    </TD></TR>
<TR><TD><B><a href="#invokes">invokes</a>(target:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,args:<A HREF="../../../Root/XCore/Element/index.html">Seq(Element)<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      This version of invoke calculates its supers from its owner which
      is then passes as the argument to the 3 argument invoke.
    </TD></TR>
<TR><TD><B><a href="#isKindOf">isKindOf</a>(c:<A HREF="../../../Root/XCore/Classifier/index.html">Classifier<A>):<A HREF="../../../Root/XCore/Boolean/index.html">Boolean<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#javaTypeName">javaTypeName</a>(type:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/String/index.html">String<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#labelString">labelString</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#legalNameChangeCheck">legalNameChangeCheck</a>(newName:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,oldName:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#matchesId">matchesId</a>(id:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#matchesSignature">matchesSignature</a>(op:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#matchesTarget">matchesTarget</a>(object:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,target:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#name">name</a>():<A HREF="../../../Root/XCore/Symbol/index.html">Symbol<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#paramNames">paramNames</a>():<A HREF="../../../Root/XCore/String/index.html">Seq(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#setDynamics">setDynamics</a>(dynamics:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#setGlobals">setGlobals</a>(globals:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Set the environment of freely reference variables.
    </TD></TR>
<TR><TD><B><a href="#setSupers">setSupers</a>(supers:<A HREF="../../../Root/XCore/Operation/index.html">Seq(Operation)<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#setTarget">setTarget</a>(target:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Set the value that will be used as 'self' in the evaluation
      of the body of the operation.
    </TD></TR>
<TR><TD><B><a href="#sig">sig</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Returns the signature of the receiver.
    </TD></TR>
<TR><TD><B><a href="#source">source</a>():<A HREF="../../../Root/XCore/String/index.html">String<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#supers">supers</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      The supers of an operation define where the search continues
      when the body performs performs 'super'
    </TD></TR>
<TR><TD><B><a href="#target">target</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Returns the value of 'self' that was current when the operation
      was created (unless the operation has been modified since).
    </TD></TR>
<TR><TD><B><a href="#toNamedElement">toNamedElement</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#toType">toType</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#trace">trace</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Call this operation to trace an operation. When
      the operation is called it will print out on
      entry and exit.
    </TD></TR>
<TR><TD><B><a href="#traceFun">traceFun</a>(fun:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      This operation returns a function that can be invoked to
      trace the operation fun.
    </TD></TR>
<TR><TD><B><a href="#traced">traced</a>():<A HREF="../../../Root/XCore/Boolean/index.html">Boolean<A></B></TD><TD>
      Returns true when the received is traced.
    </TD></TR>
<TR><TD><B><a href="#unbreak">unbreak</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Call this operation to unbreak an operation.
    </TD></TR>
<TR><TD><B><a href="#untrace">untrace</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>
      Call this operation to untrace an operation.
    </TD></TR>
<TR>
<TD COLSPAN=2>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../Root/XCore/DocumentedElement/index.html">DocumentedElement</A>: doc, ensureDoc, setDoc. <BR><B>From</B> <A HREF="../../../Root/XCore/NamedElement/index.html">NamedElement</A>: getNamedElement, href, labelString, legalNameChangeCheck, name, path, pathSeq, repopulate, setName, toString. <BR><B>From</B> <A HREF="../../../Root/XCore/Contained/index.html">Contained</A>: addTo, allOwners, deleteRecursive, delete_client, delete_client_check, delete_client_redirect, getDefaultClipboardSource, owner, removeFromOwner, setOwner. <BR><B>From</B> <A HREF="../../../Root/XCore/Object/index.html">Object</A>: addDaemon, addDiagramListener, addMissingSlot, addMultiDaemon, addPersistentDaemon, addStructuralFeature, allCompositeValues, allCompositeValuesAndSelf, allDaemonsWithId, allDaemonsWithTarget, applyMapping_client, calcChildrenSlots, changedOnDiagram, compositeValues, daemonNamed, daemonWithId, daemonWithIdAndTarget, daemons, daemonsActive, destroyDaemon, edit, fire, get, getAvailableMappings, getChildren, getChildrenSlots, getChildrenToolTips, getDiagramListenerNamed, getDiagramListeners, getProperties, getProperty, getStructuralFeatureNames, hasDaemonNamed, hasDaemonWithId, hasDaemonWithIdAndTarget, hasDaemonWithTarget, hasProperty, hasSlot, hasStructuralFeature, hotLoad, hotLoaded, ignoreBy, ignoreByAll, init, initSlots, machineInit, nodeEvent, observeBy, observeBy, observedBy, observedBy, oldEdit, orderSequence, orderSequence, propertyTarget, removeDaemon, removeDaemonNamed, removeDaemonsWithId, removeDaemonsWithTarget, removeDiagramListener, removeDiagramListeners, removeStructuralFeature, renameSlot, saveXTO, saveXTOFile, set, setDaemons, setDaemonsActive, setHotLoad, setProperty, showAndLayoutDiagram, showDiagram, slotDenied, slotMissing, slotMissing, slots, synchronise. <BR><B>From</B> <A HREF="../../../Root/XCore/Element/index.html">Element</A>: addTo, allHTMLEntries, allHTMLPackages, assignToGlobal, assignToGlobal, browse, browse_redirect, checkConstraints, copy, copyToClipboard, copyToClipboard_transaction, createDiagram, createDiagramType, createDiagramType, createDiagramType, createTool, cutToClipboard, cutToClipboard_transaction, deleteRecursive, deployXML, die, doc, doubleClick, edit, edit_redirect, equals, error, evaluateExpression, ferror, getChildren, getChildrenToolTips, getDefaultClipboardSource, getDefaultClipboardTarget, graphVizNode, hashCode, init, init, invokeOp, isDeleteProtected, isKindOf, isProtected, isReallyKindOf, isTypeOf, isViewProtected, isWithinNameSpace, labelString, legalNameChangeCheck, legalSlotChangeCheck, legalSlotChangeCheck, lift, nameString, noOperationFound, oclIsKindOf, oclIsTypeOf, of, oldShowDiagram, pasteFromClipboard, populateGraphViz, pprint, pprint, pprint, pprintln, print, println, removeDaemon, removeDaemon, save, save2, selectDiagram, selectModelBrowserNode, send, setDelegation, setOf, setRoleFillerDialog, showAndLayoutDiagram, showDiagram, showModelBrowserNode, slotAffectsLabel, systemId, toHTML, toSVG, toSnapshot, toSnapshot, toString, toType, writeHTML, writeHTML, writeHTMLAllEntries, writeHTMLAllPackages, writeHTMLIndex, writeHTMLOverview, writeXML, writeXMLFile, yield. <BR><TR><TD COLSPAN=2><a name="arity"/><FONT FACE="Courier" SIZE="1">@Operation&#160;arity():Integer<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;arity&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="break"/><FONT FACE="Courier" SIZE="1">@Operation&#160;break():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;break&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="breakFun"/><FONT FACE="Courier" SIZE="1">@Operation&#160;breakFun(fun&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;let&#160;breakFun&#160;=&#160;@Operation&#160;anonymous(target&#160;:&#160;XCore::Element,args&#160;:&#160;XCore::Element,supers&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;op&#160;=&#160;fun.copy();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;names&#160;=&#160;self.paramNames()&#160;then<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pairs&#160;=&#160;names.zip(args)&#160;then<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;env&#160;=&#160;pairs-&gt;iterate(p&#160;e&#160;=&#160;Env::NullEnv()&#160;|<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;e.bind(p-&gt;head,p-&gt;tail));<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ex&#160;=&#160;Exception(formats("Break&#160;~S.~S(~{,~;~S~})~%",Seq{target,fun.name(),args}))<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;op.untrace();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format(stdout,"Enter&#160;Break&#160;~S.~S(~{,~;~S~})~%",Seq{target,fun.name(),args});<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;@For&#160;name,arg&#160;in&#160;names,args&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format(stdout,"&#160;&#160;~S&#160;=&#160;~S~%",Seq{name,arg})<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ex.edit();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xmf.topLevel().loop(target,env,"Break&gt;&#160;",false,Seq{XCore,Root});<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;value&#160;=&#160;Kernel_invoke(op,target,args,supers)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;format(stdout,"Exit&#160;Break&#160;~S.~S(~{,~;~S~})&#160;=&gt;&#160;~S~%",Seq{target,fun.name(),args,value});<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch(exception)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format(stdout,"Error&#160;in&#160;breakpoint.");<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;exception<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;in&#160;if&#160;owner.isReallyKindOf(Classifier)<br>&#160;&#160;&#160;&#160;&#160;then&#160;let&#160;supers&#160;=&#160;Kernel_operatorPrecedenceList(owner)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;@While&#160;(not&#160;supers-&gt;isEmpty)&#160;andthen&#160;(not&#160;supers-&gt;head&#160;=&#160;self)&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;supers&#160;:=&#160;supers-&gt;tail<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;supers-&gt;isEmpty<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;breakFun.supers&#160;:=&#160;Seq{breakFun}<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;breakFun.supers&#160;:=&#160;supers<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;breakFun<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;else&#160;breakFun<br>&#160;&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="calcChildrenSlots"/><FONT FACE="Courier" SIZE="1">@Operation&#160;calcChildrenSlots():XCore::Element<br>&#160;&#160;Seq{}<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="deployJava"/><FONT FACE="Courier" SIZE="1">@Operation&#160;deployJava(out&#160;:&#160;OutputChannel):XCore::Element<br>&#160;&#160;format(out,"&#160;&#160;public&#160;~S&#160;~S(",Seq{self.javaTypeName(self.type()),self.name()});<br>&#160;&#160;@For&#160;name,type&#160;in&#160;self.paramNames(),self.paramTypes()&#160;do<br>&#160;&#160;&#160;&#160;format(out,"~S&#160;~S",Seq{self.javaTypeName(type),name});<br>&#160;&#160;&#160;&#160;if&#160;not&#160;isLast<br>&#160;&#160;&#160;&#160;then&#160;format(out,",")<br>&#160;&#160;&#160;&#160;else&#160;false<br>&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;end;<br>&#160;&#160;format(out,")&#160;{~%");<br>&#160;&#160;format(out,"&#160;&#160;&#160;&#160;return&#160;null;~%");<br>&#160;&#160;format(out,"&#160;&#160;}~%")<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="dynamics"/><FONT FACE="Courier" SIZE="1">@Operation&#160;dynamics():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;dynamics&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="fork"/><FONT FACE="Courier" SIZE="1">@Operation&#160;fork(name&#160;:&#160;String):XCore::Element<br>&#160;&#160;Kernel_fork(name,@Operation&#160;anonymous():XCore::Element<br>&#160;&#160;&#160;&#160;self.invoke(self,Seq{})<br>&#160;&#160;end)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="fork"/><FONT FACE="Courier" SIZE="1">@Operation&#160;fork():XCore::Element<br>&#160;&#160;Kernel_fork("Unknown",@Operation&#160;anonymous():XCore::Element<br>&#160;&#160;&#160;&#160;self.invoke(self,Seq{})<br>&#160;&#160;end)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="getDerivedValue"/><FONT FACE="Courier" SIZE="1">@Operation&#160;getDerivedValue(cache&#160;:&#160;Table,this&#160;:&#160;XCore::Element,args&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;if&#160;not&#160;cache.hasKey(this)<br>&#160;&#160;then&#160;cache.put(this,Seq{})<br>&#160;&#160;else&#160;false<br>&#160;&#160;end&#160;;<br>&#160;&#160;let&#160;findSeq&#160;=&#160;cache.get(this)-&gt;asSeq;<br>&#160;&#160;&#160;&#160;&#160;&#160;findDone&#160;=&#160;false;<br>&#160;&#160;&#160;&#160;&#160;&#160;findResult&#160;=&#160;null<br>&#160;&#160;in&#160;declare(hidden,findSeq);<br>&#160;&#160;&#160;&#160;&#160;declare(hidden,findDone);<br>&#160;&#160;&#160;&#160;&#160;declare(hidden,findResult);<br>&#160;&#160;&#160;&#160;&#160;@While&#160;not&#160;findSeq-&gt;isEmpty&#160;and&#160;not&#160;findDone&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;entry&#160;=&#160;findSeq-&gt;head&#160;then<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;findElement&#160;=&#160;findSeq-&gt;head<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;declare(hidden,findElement);<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;entry-&gt;head-&gt;size&#160;=&#160;args-&gt;size&#160;andthen&#160;entry-&gt;head.zip(args)-&gt;forAll(pair&#160;|<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;pair-&gt;head&#160;=&#160;pair-&gt;tail)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;findDone&#160;:=&#160;true;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;findResult&#160;:=&#160;entry-&gt;tail<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;findSeq&#160;:=&#160;findSeq-&gt;tail<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;end;<br>&#160;&#160;&#160;&#160;&#160;if&#160;not&#160;findDone<br>&#160;&#160;&#160;&#160;&#160;then&#160;let&#160;value&#160;=&#160;self.invoke(this,args)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;cache.put(this,Seq{Seq{args&#160;|&#160;value}&#160;|&#160;cache.get(this)});<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;else&#160;findResult<br>&#160;&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="globals"/><FONT FACE="Courier" SIZE="1">@Operation&#160;globals():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;globals&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="invoke"/><FONT FACE="Courier" SIZE="1">@Operation&#160;invoke(target&#160;:&#160;Element,args&#160;:&#160;Seq(Element),supers&#160;:&#160;Seq(Operation)):Element<br>&#160;&#160;if&#160;not&#160;self.isVarArgs()&#160;and&#160;args-&gt;size&#160;=&#160;self.arity()<br>&#160;&#160;then&#160;Kernel_invoke(self,target,args,supers)<br>&#160;&#160;elseif&#160;self.isVarArgs()&#160;and&#160;args-&gt;size&#160;&gt;=&#160;self.arity()&#160;-&#160;1<br>&#160;&#160;then&#160;Kernel_invoke(self,target,args-&gt;take(self.arity()&#160;-&#160;1)&#160;+&#160;Seq{args-&gt;drop(self.arity()&#160;-&#160;1)},supers)<br>&#160;&#160;else&#160;throw&#160;Exceptions::ArityError(self,args)<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="invoke"/><FONT FACE="Courier" SIZE="1">@Operation&#160;invoke(target&#160;:&#160;Element,args&#160;:&#160;Seq(Element)):Element<br>&#160;&#160;if&#160;not&#160;self.isVarArgs()&#160;and&#160;args-&gt;size&#160;=&#160;self.arity()<br>&#160;&#160;then&#160;Kernel_invoke(self,target,args,self.supers)<br>&#160;&#160;elseif&#160;self.isVarArgs()&#160;and&#160;args-&gt;size&#160;&gt;=&#160;self.arity()&#160;-&#160;1<br>&#160;&#160;then&#160;Kernel_invoke(self,target,args-&gt;take(self.arity()&#160;-&#160;1)&#160;+&#160;Seq{args-&gt;drop(self.arity()&#160;-&#160;1)},self.supers)<br>&#160;&#160;else&#160;throw&#160;Exceptions::ArityError(self,args)<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="invokes"/><FONT FACE="Courier" SIZE="1">@Operation&#160;invokes(target&#160;:&#160;Element,args&#160;:&#160;Seq(Element)):Element<br>&#160;&#160;if&#160;owner&#160;&lt;&gt;&#160;null<br>&#160;&#160;then&#160;let&#160;ops&#160;=&#160;owner.allOperations()<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;@While&#160;not&#160;self.matchesSignature(ops-&gt;head)&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ops&#160;:=&#160;ops-&gt;tail<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;self.invoke(target,args,ops)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;else&#160;self.invoke(target,args)<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="isKindOf"/><FONT FACE="Courier" SIZE="1">@Operation&#160;isKindOf(c&#160;:&#160;Classifier):Boolean<br>&#160;&#160;if&#160;c.isKindOf(OpType)<br>&#160;&#160;then&#160;c.matchesSig(self.sig(),self.imports())<br>&#160;&#160;else&#160;c.inheritsFrom(Operation)<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="javaTypeName"/><FONT FACE="Courier" SIZE="1">@Operation&#160;javaTypeName(type&#160;:&#160;Element):String<br>&#160;&#160;@Case&#160;type&#160;of<br>&#160;&#160;&#160;&#160;Integer&#160;:&#160;XCore::Element&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;"int"<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;Boolean&#160;:&#160;XCore::Element&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;"boolean"<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;String&#160;:&#160;XCore::Element&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;"String"<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;SetOfElement&#160;:&#160;XCore::Element&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;"Vector"<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;SeqOfElement&#160;:&#160;XCore::Element&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;"Vector"<br>&#160;&#160;&#160;&#160;end<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="labelString"/><FONT FACE="Courier" SIZE="1">@Operation&#160;labelString():XCore::Element<br>&#160;&#160;self.name.toString()&#160;+&#160;"()"<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="legalNameChangeCheck"/><FONT FACE="Courier" SIZE="1">@Operation&#160;legalNameChangeCheck(newName&#160;:&#160;XCore::Element,oldName&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;newName&#160;:=&#160;Symbol(newName.toString());<br>&#160;&#160;if&#160;newName.toString()&#160;=&#160;""<br>&#160;&#160;then&#160;<br>&#160;&#160;&#160;&#160;xmf.warning("Cannot&#160;set&#160;name&#160;of&#160;"&#160;+&#160;oldName&#160;+&#160;"&#160;to&#160;""&#160;+&#160;newName&#160;+&#160;"".&#160;The&#160;empty&#160;string&#160;is&#160;"&#160;+&#160;"not&#160;a&#160;valid&#160;name&#160;for&#160;a&#160;named&#160;element.");<br>&#160;&#160;&#160;&#160;false<br>&#160;&#160;elseif&#160;not&#160;newName.isValidName()<br>&#160;&#160;then&#160;<br>&#160;&#160;&#160;&#160;xmf.warning("Cannot&#160;set&#160;name&#160;of&#160;"&#160;+&#160;oldName&#160;+&#160;"&#160;to&#160;""&#160;+&#160;newName&#160;+&#160;""&#160;as&#160;the&#160;name&#160;is&#160;illegal.&#160;"&#160;+&#160;"A&#160;valid&#160;name&#160;must&#160;start&#160;with&#160;a&#160;letter,&#160;followed&#160;by&#160;letters,&#160;numbers&#160;or&#160;an&#160;underscore.");<br>&#160;&#160;&#160;&#160;false<br>&#160;&#160;else&#160;true<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="matchesId"/><FONT FACE="Courier" SIZE="1">@Operation&#160;matchesId(id&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;false<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="matchesSignature"/><FONT FACE="Courier" SIZE="1">@Operation&#160;matchesSignature(op&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;op.name()&#160;=&#160;self.name&#160;and&#160;op.arity()&#160;=&#160;self.arity()<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="matchesTarget"/><FONT FACE="Courier" SIZE="1">@Operation&#160;matchesTarget(object&#160;:&#160;XCore::Element,target&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;false<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="name"/><FONT FACE="Courier" SIZE="1">@Operation&#160;name():Symbol<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;name&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="paramNames"/><FONT FACE="Courier" SIZE="1">@Operation&#160;paramNames():Seq(String)<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;paramNames&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="setDynamics"/><FONT FACE="Courier" SIZE="1">@Operation&#160;setDynamics(dynamics&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;setDynamics&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="setGlobals"/><FONT FACE="Courier" SIZE="1">@Operation&#160;setGlobals(globals&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;setGlobals&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="setSupers"/><FONT FACE="Courier" SIZE="1">@Operation&#160;setSupers(supers&#160;:&#160;Seq(Operation)):XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;setSupers&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="setTarget"/><FONT FACE="Courier" SIZE="1">@Operation&#160;setTarget(target&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;setTarget&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="sig"/><FONT FACE="Courier" SIZE="1">@Operation&#160;sig():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;sig&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="source"/><FONT FACE="Courier" SIZE="1">@Operation&#160;source():String<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;source&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="supers"/><FONT FACE="Courier" SIZE="1">@Operation&#160;supers():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;supers&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="target"/><FONT FACE="Courier" SIZE="1">@Operation&#160;target():Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;target&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="toNamedElement"/><FONT FACE="Courier" SIZE="1">@Operation&#160;toNamedElement():XCore::Element<br>&#160;&#160;Operation(self.paramTypes()-&gt;collect(t&#160;|<br>&#160;&#160;&#160;&#160;Delayed(@Operation&#160;anonymous():XCore::Element<br>&#160;&#160;&#160;&#160;t.toType()<br>&#160;&#160;end)),Delayed(@Operation&#160;anonymous():XCore::Element<br>&#160;&#160;&#160;&#160;self.type().toType()<br>&#160;&#160;end))<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="toType"/><FONT FACE="Courier" SIZE="1">@Operation&#160;toType():XCore::Element<br>&#160;&#160;Fun(self.paramTypes()-&gt;map("toType"),self.type().toType())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="trace"/><FONT FACE="Courier" SIZE="1">@Operation&#160;trace():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;trace&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="traceFun"/><FONT FACE="Courier" SIZE="1">@Operation&#160;traceFun(fun&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;let&#160;traceFun&#160;=&#160;@Operation&#160;anonymous(target&#160;:&#160;XCore::Element,args&#160;:&#160;XCore::Element,supers&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;try<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;op&#160;=&#160;fun.copy()<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;op.untrace();<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Operation::TraceIndent&#160;:=Operation::TraceIndent&#160;+&#160;1;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format(stdout,"~VEnter&#160;~S.~S(~{,~;~S~})~%",Seq{Operation::TraceIndent&#160;*&#160;2,target,fun.name(),args});<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;let&#160;value&#160;=&#160;Kernel_invoke(op,target,args,supers)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;format(stdout,"~VExit&#160;~S.~S&#160;=&#160;~S~%",Seq{Operation::TraceIndent&#160;*&#160;2,target,fun.name(),value});<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Operation::TraceIndent&#160;:=Operation::TraceIndent&#160;-&#160;1;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;value<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;catch(exception)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;format(stdout,"~VError&#160;~S&#160;in&#160;~S~%",Seq{Operation::TraceIndent&#160;*&#160;2,exception,fun.name()});<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Operation::TraceIndent&#160;:=Operation::TraceIndent&#160;-&#160;1;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;exception<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;in&#160;if&#160;owner.isReallyKindOf(Classifier)<br>&#160;&#160;&#160;&#160;&#160;then&#160;let&#160;supers&#160;=&#160;Kernel_operatorPrecedenceList(owner)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;in&#160;@While&#160;(not&#160;supers-&gt;isEmpty)&#160;andthen&#160;(not&#160;supers-&gt;head&#160;=&#160;self)&#160;do<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;supers&#160;:=&#160;supers-&gt;tail<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;supers-&gt;isEmpty<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;traceFun.supers&#160;:=&#160;Seq{traceFun}<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;traceFun.supers&#160;:=&#160;supers<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;;<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;traceFun<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end<br>&#160;&#160;&#160;&#160;&#160;else&#160;traceFun<br>&#160;&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="traced"/><FONT FACE="Courier" SIZE="1">@Operation&#160;traced():Boolean<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;traced&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="unbreak"/><FONT FACE="Courier" SIZE="1">@Operation&#160;unbreak():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;unbreak&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="untrace"/><FONT FACE="Courier" SIZE="1">@Operation&#160;untrace():XCore::Element<br>&#160;&#160;self.error("I&#160;don&apos;t&#160;know&#160;how&#160;to&#160;perform&#160;untrace&#160;for&#160;"&#160;+&#160;self.toString())<br>end</FONT>
</TD></TR>
</FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Grammar</B></FONT></TD>
</TR>
<TD><PRE>
ReturnType ::=  ':'   PushChar   TypeExp   PopChar  | { NamedType() }.
SetCmpExp ::=  LinePos   = l   '{'   CommaSepExps   = es   '}'   !  { SetExp(l,"Set",es) } |  LinePos   = l   '{'   Exp   = e   '|'   CmpClause   = c   SetCmpExp-Star0   = cs   '}'  { Comprehensions::Cmp("Set",e,Seq{c | cs}) }.
Properties ::=  '['   Property   = p   Properties-Star0   = ps   ']'   <Pair 2ec26d>  |  Seq{} .
AddPattern-Dis0 ::=  '+'   AddPattern   = p2  { Addp(p1,p2) } |  <VarRef 2a69db> .
OpMulti ::=  '.'   PushChar   Pattern   PopChar   = multi  { Seq{multi} } |  Seq{} .
BindValue ::=  OptType   = type   '='   SimpleExp   = value  { ValueBinding(name,type,value) }.
Property ::=  Name   = n   '='   PushChar   Exp   PopChar   = e  { Seq{n,e} } |  Name   = n  { Seq{n,[| true |]} }.
Def ::=  'context'   Def-Dis0   = isForward   ImportPath   = path   PushChar   Exp   PopChar   = exp  { ContextDef(path,exp,isForward) }.
OpArg ::=  PushChar   Pattern   PopChar  |  '!'   Drop .
LocalParserImport-Star0 ::=  '::'   Name   = $head   LocalParserImport-Star0   = $tail   Cons  |  Nil .
Properties-Star0 ::=  ','   Property   = $head   Properties-Star0   = $tail   Cons  |  Nil .
NonEmptySeqTail ::=  PushChar   Expr   PopChar   = e   PairOrElements .
OpArgs ::=  OpArg   = arg   OpArgs-Star0   = args   <Pair 2c7403>  |  Seq{} .
Import ::=  PushChar   'import'   ImportPath   = path   ';'  { Import(path) }  PopChar .
OpArgs-Star0 ::=  ','   OpArg   = $head   OpArgs-Star0   = $tail   Cons  |  Nil .
Varp ::=  AName   = name   Varp-Dis0   = pattern   Varp-Dis1   = type  { Varp(name,pattern,type) }.
OpName ::=  AName   = name  { if name.isKindOf(String)
then Symbol(name)
else name
end  } | { Symbol("anonymous") }.
IfTail ::=  'else'   PushChar   Expr   PopChar   'end'  |  LinePos   = l   'elseif'   PushChar   Expr   PopChar   = e1   'then'   PushChar   Expr   PopChar   = e2   IfTail   = e3  { If(l,e1,e2,e3) } |  'end'  { BoolExp(false) }.
Operation-PlusCons0 ::=  PushChar   Exp   PopChar   = $head   Operation-PlusCons0-Star0   = $tail   Cons .
AddPattern ::=  AtomicPattern   = p1   AddPattern-Dis0 .
Operation ::=  OpName   = name   Properties   = ps   '('   OpArgs   = args   OpMulti   = multi   ')'   PushChar   ReturnType   PopChar   = type   Operation-PlusCons0   = body   'end'   pState   = p  { ps->iterate(p x = Operation(name,args + multi,type).add(body).setIsMultiArgs(not multi->isEmpty).setImports(p.imports->excluding(XCore)->excluding(Root)->map("pathSeq")).setProperties(ps) |
  [| <x>.setProperty(<StrExp(p->at(0))>,<p->at(1)>) |]) }.
Keyps-Star0 ::=  ','   Keyp   = $head   Keyps-Star0   = $tail   Cons  |  Nil .
Operation-PlusCons0-Star0 ::=  PushChar   Exp   PopChar   = $head   Operation-PlusCons0-Star0   = $tail   Cons  |  Nil .
VarExp ::=  Name   = name   LinePos   = l  { Var(name,l) }.
Keywordp ::=  Name   = name   Keywordp-Star0   = names   '['   Keyps   = keys   ']'  { Keywordp(name,names,keys) }.
BindingList ::=  PushChar   Binding   PopChar   = binding   BindingList-Star0   = bindings   <Pair 31dc6e> .
SeqCmpExp-Star0 ::=  ','   CmpClause   = $head   SeqCmpExp-Star0   = $tail   Cons  |  Nil .
Objectp ::=  Name   = name   Objectp-Star0   = names   '('   Patterns   = slots   ')'  { Objectp(name,names,slots) }.
EvaluationUnit ::=  EvaluationUnit-Star0   EvaluationUnit-Star1   = imports   EvaluationUnit-Star2   = exps   EOF  { Evaluator::EvaluationUnit(imports,exps) }.
SeqCmpExp ::=  LinePos   = l   '['   CommaSepExps   = es   ']'   !  { SetExp(l,"Seq",es) } |  LinePos   = l   '['   Exp   = e   '|'   CmpClause   = c   SeqCmpExp-Star0   = cs   ']'  { Comprehensions::Cmp(e,Seq{c | cs}) }.
Atom ::=  PushChar   VarExp   PopChar   !  |  PushChar   Self   PopChar   !  |  PushChar   StrExp   PopChar   !  |  PushChar   IntExp   PopChar   !  |  PushChar   IfExp   PopChar   !  |  PushChar   BoolExp   PopChar   !  |  PushChar   LetExp   PopChar   !  |  PushChar   CollExp   PopChar   !  |  Parentheses  |  PushChar   Drop   PopChar  |  PushChar   Lift   PopChar  |  PushChar   Throw   PopChar  |  PushChar   Try   PopChar  |  PushChar   ImportIn   PopChar  |  PushChar   FloatExp   PopChar  |  PushChar   LocalParserImport   PopChar  |  PushChar   AtExp   PopChar .
Constp ::=  Intp  |  Strp  |  Boolp  |  Expp .
EvaluationUnit-Star2-Dis0 ::=  Def  |  TopLevelExp .
SeqExp ::=  LinePos   = l   'Seq{'   SeqExp-Dis0 .
Syntaxp ::=  '[|'   PushChar   Exp   PopChar   = e   '|]'  { Syntaxp(e) }.
ArgsTail-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   ArgsTail-Star0   = $tail   Cons  |  Nil .
CollMessage ::=  '('   CommaSepExps   = as   ')'  { CollExp(c,n,as) }.
BindFunArgsTail ::=  Pattern   = p   BindFunArgsTail-Star0   = ps   ')'   <Pair 3f53cf>  |  ')'   Seq{} .
PathExp ::=  PushChar   Atom   PopChar   = atom   PathExp-Dis0 .
Drop ::=  '<'   DropExp   = e   '>'  { Drop(resolve(order(e))) } |  '<|'   Pattern   = p   '|>'  { DropPattern(p) }.
Parentheses ::=  '('   PushChar   Expr   PopChar   = e   ')'  { Parentheses(e) }.
Objectp-Star0 ::=  '::'   Name   = $head   Objectp-Star0   = $tail   Cons  |  Nil .
CollOp ::=  CollMessage  |  Collect  |  Iterate  | { CollExp(c,n,Seq{}) }.
LogicalExp ::=  PushChar   SimpleExp   PopChar   = e  { resolve(order(e)) }.
Throw ::=  LinePos   = l   'throw'   PushChar   SimpleExp   PopChar   = value  { Throw(l,value) }.
ImportPath ::=  Name   = n   ImportPath-Star0   = ns   <Pair 43733a> .
EvaluationUnit-Star2 ::=  EvaluationUnit-Star2-Dis0   = $head   EvaluationUnit-Star2   = $tail   Cons  |  Nil .
Varp-Dis0 ::=  '='   PushChar   Pattern   PopChar  |  null .
ArrowTail ::=  Name   = n   CollOp   = x   Arrow .
IfExp ::=  LinePos   = l   'if'   PushChar   Expr   PopChar   = e1   'then'   PushChar   Expr   PopChar   = e2   IfTail   = e3  { If(l,e1,e2,e3) }.
Exp ::=  PushChar   Expr   PopChar   = e   !  { resolve(order(e)) }.
AName ::=  Name   !  |  Drop .
SetCmpExp-Star0 ::=  ','   CmpClause   = $head   SetCmpExp-Star0   = $tail   Cons  |  Nil .
Keywordp-Star0 ::=  '::'   Name   = $head   Keywordp-Star0   = $tail   Cons  |  Nil .
KeyArg ::=  Name   = name   '='   PushChar   Expr   PopChar   = exp  { KeyArg(name,exp) }.
Try ::=  LinePos   = l   'try'   PushChar   Expr   PopChar   = body   'catch'   '('   Name   = name   ')'   PushChar   Expr   PopChar   = handler   'end'  { Try(l,body,name,handler) }.
Keyps ::=  Keyp   = key   Keyps-Star0   = keys   <Pair 4e9609>  |  Seq{} .
Bindings ::=  BindingList  |  Drop .
Patterns-Star0 ::=  ','   Pattern   = $head   Patterns-Star0   = $tail   Cons  |  Nil .
Op ::=  BinOp   !  |  ';'   ; .
EmptySeqTail ::=  '}'  { SetExp(l,"Seq",Seq{}) }.
SetExp ::=  LinePos   = l   'Set{'   CommaSepExps   = es   '}'  { SetExp(l,"Set",es) }.
AtExp ::=  LinePos   = l   '@'   PushChar  At  PopChar   = e  { e.setLine(l) }.
Consp ::=  Pairp  |  Seqp  |  Emptyp .
Def-Dis0 ::=  '!'  { true } | { false }.
Seqp ::=  'Seq{'   Pattern   = head   SeqpTail   = tail  { Consp(head,tail) }.
Strp ::=  Str   = s  { Constp(StrExp(s)) }.
BindFunArgsTail-Star0 ::=  ','   Pattern   = $head   BindFunArgsTail-Star0   = $tail   Cons  |  Nil .
Collect ::=  '('   AName   = v   '|'   PushChar   Expr   PopChar   = e   ')'  { IterExp(c,n,v,e) }.
BindFunArgs ::=  '('   BindFunArgsTail .
Pattern ::=  AddPattern   = p   Pattern-Star0   = es  { es->iterate(e s = p |
  Includingp(s,e)) }  = p   PatternGuard .
DropExp ::=  'not'   DropExp   = e  { Negate(e) } |  PushChar   Apply   PopChar   = a   DropExpTail .
ParserImport ::=  'parserImport'   Name   = name   ParserImport-Star0   = names   ';'   <Pair 4914f1>  ImportAt { ParserImport(Seq{name} + names,null) }.
PairOrElements-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   PairOrElements-Star0   = $tail   Cons  |  Nil .
CollExp ::=  PushChar   SetExp   PopChar   !  |  PushChar   SeqExp   PopChar   !  |  PushChar   SetCmpExp   PopChar   !  |  PushChar   SeqCmpExp   PopChar   ! .
LocalParserImport ::=  'parserImport'   Name   = name   LocalParserImport-Star0   = names   <Pair 6112ec>  ImportAt  'in'   PushChar   Expr   PopChar   = e   'end'  { ParserImport(Seq{name | names},e) }.
TopLevelExp ::=  PushChar   SimpleExp   PopChar   = s   ';'  { resolve(order(s)) }.
ImportIn ::=  'import'   ImportPath   = path   'in'   PushChar   Exp   PopChar   = body   'end'  { ImportIn(path,body) }.
EvaluationUnit-Star1 ::=  EImport   = $head   EvaluationUnit-Star1   = $tail   Cons  |  Nil .
Varp-Dis1 ::=  ':'   PushChar   TypeExp   PopChar  | { NamedType() }.
ArgsTail ::=  ')'   Seq{}  |  PushChar   Expr   PopChar   = arg   ArgsTail-Star0   = args   ')'   <Pair 39f82f> .
FloatExp ::=  LinePos   = l   Float   = f  { f.lift().line := l }.
Expr ::=  'not'   PushChar   Expr   PopChar   = e  { Negate(e) } |  '-'   PushChar   SimpleExp   PopChar   = e  { BinExp(IntExp(0),"-",e) } |  PushChar   Apply   PopChar   = a   ExpTail .
Apply ::=  PushChar   Atom   PopChar   = a   ApplyTail   = e   Arrow .
SeqExp-Dis0 ::=  EmptySeqTail  |  NonEmptySeqTail .
KeyArgs-Dis0 ::=  ']'   Seq{}  |  KeyArg   = arg   KeyArgs-Dis0-Star0   = args   ']'   <Pair 39f9c8> .
KeyArgs ::=  '['   KeyArgs-Dis0 .
TypePath ::=  Name   = name   TypePath-Star0   = names  { Seq{name | names}->collect(n |
  Symbol(n)) }.
Keyp ::=  Name   = name   '='   Pattern   = pattern  { Keyp(name,pattern) }.
BinOp ::=  '<'   <  |  '<='   <=  |  '>'   >  |  '>='   >=  |  '<>'   <>  |  '='   =  |  '::'   ::  |  ':='   :=  |  '.'   .  |  'and'   and  |  'andthen'   andthen  |  'implies'   implies  |  'or'   or  |  'orelse'   orelse  |  '+'   +  |  '-'   -  |  '*'   *  |  '/'   / .
Pattern-Star0 ::=  PatternTail   = $head   Pattern-Star0   = $tail   Cons  |  Nil .
OpType ::=  TypeArgs   = domains   '->'   PushChar   TypeExp   PopChar   = range  { OpType(domains,range) }.
Emptyp ::=  'Seq{'   '}'  { Constp(SetExp("Seq",Seq{})) } |  'Set{'   '}'  { Constp(SetExp("Set",Seq{})) }.
Self ::=  LinePos   = l   'self'  { Self(l) }.
AtomicPattern ::=  PushChar   Varp   PopChar  |  PushChar   Constp   PopChar  |  PushChar   Objectp   PopChar  |  PushChar   Consp   PopChar  |  PushChar   Keywordp   PopChar  |  PushChar   Syntaxp   PopChar  |  '('   PushChar   Pattern   PopChar   ')' .
CompilationBodyExps ::=  CompilationBody   = b   !   CompilationBodyExps   = bs   <Pair 4374d6>  |  Seq{} .
CompilationUnit-Star0 ::=  ParserImport   = $head   CompilationUnit-Star0   = $tail   Cons  |  Nil .
SeqpTail ::=  ','   Pattern   = head   SeqpTail   = tail  { Consp(head,tail) } |  '}'  { Constp(SetExp("Seq",Seq{})) }.
StrExp ::=  LinePos   = l   Str   = e  { StrExp(l,e) }.
BindingList-Star0 ::=  ';'   PushChar   Binding   PopChar   = $head   BindingList-Star0   = $tail   Cons  |  Nil .
CommaSepExps ::=  PushChar   Expr   PopChar   = e   CommaSepExps-Star0   = es   <Pair 41e965>  |  Seq{} .
BindFun ::=  BindFunArgs   = args   OptType   = type   '='   PushChar   SimpleExp   PopChar   = value  { FunBinding(name,args,type,value) }.
PatternGuard ::=  'when'   PushChar   Exp   PopChar   = e  { Condp(p,e) } |  <VarRef 3f5172> .
DropExpTail ::=  DropOp   = o   !   DropExp   = e  { BinExp(a,o,e) } |  <VarRef 41e63c> .
Pairp ::=  'Seq{'   Pattern   = head   '|'   Pattern   = tail   '}'  { Consp(head,tail) }.
ParserImport-Star0 ::=  '::'   Name   = $head   ParserImport-Star0   = $tail   Cons  |  Nil .
CmpClause ::=  Name   = n   OptType   = t   '<-'   PushChar   Exp   PopChar   = e  { Comprehensions::Bind(n,t.toExp(),e) } |  '?'   PushChar   Exp   PopChar   = e  { Comprehensions::Filter(e) }.
Lift ::=  LinePos   = l   '[|'   PushChar   Exp   PopChar   = e   '|]'  { Lift(l,e) }.
TopLevelCommand ::=  PushChar   SimpleExp   PopChar   = c   pState   = p  { p.consumeToken := false }  ';'  { resolve(order(c)) }.
IntExp ::=  LinePos   = l   Int   = e  { IntExp(l,e) }.
EvaluationUnit-Star0 ::=  ParserImport   = $head   EvaluationUnit-Star0   = $tail   Cons  |  Nil .
TypePath-Star0 ::=  '::'   Name   = $head   TypePath-Star0   = $tail   Cons  |  Nil .
Args ::=  '('   ArgsTail .
Expp ::=  '['   PushChar   Exp   PopChar   = exp   ']'  { Constp(exp) }.
ExpTail ::=  Op   = o   !   PushChar   Expr   PopChar   = e  { BinExp(a,o,e) } |  <VarRef 401f53> .
ApplyTail ::=  Args   = args   !  { Apply(a,args) } |  KeyArgs   = args   !  { Instantiate(a,args) } |  <VarRef f2a38> .
TypeExp-Dis0 ::=  TypeArgs   = args  { ParametricType(path,args) } | { NamedType(path) }.
KeyArgs-Dis0-Star0 ::=  ','   KeyArg   = $head   KeyArgs-Dis0-Star0   = $tail   Cons  |  Nil .
Iterate ::=  '('   AName   = v1   AName   = v2   '='   PushChar   Expr   PopChar   = init   '|'   PushChar   Expr   PopChar   = body   ')'  { Iterate(c,v1,v2,init,body) }.
TypeArgs ::=  '('   PushChar   TypeExp   PopChar   = arg   TypeArgs-Star0   = args   ')'   <Pair 43460e> .
LetBody ::=  'in'   PushChar   Expr   PopChar   = body   <VarRef 4860c9>  |  PushChar   'then'   PushChar   Bindings   PopChar   = bindings   LetBody   = body  { Let(bindings,body) }  PopChar .
BoolExp ::=  LinePos   = l   'true'  { BoolExp(l,true) } |  LinePos   = l   'false'  { BoolExp(l,false) }.
PathExp-Dis0 ::=  '::'   AName   = name   PathExp-Dis0-Star0   = names  { Path(atom,Seq{name | names}) } |  <VarRef 39fb59> .
OptType ::=  ':'   PushChar   TypeExp   PopChar  | { NamedType() }.
EImport ::=  'import'   TopLevelExp   = exp  { Evaluator::Import(exp) }.
Patterns ::=  Pattern   = head   Patterns-Star0   = tail   <Pair 5d503d>  |  Seq{} .
Binding ::=  AName   = name   BindingTail .
CompilationBody ::=  Def  |  TopLevelExp .
CompilationUnit-Star1 ::=  Import   = $head   CompilationUnit-Star1   = $tail   Cons  |  Nil .
SimpleExp ::=  'not'   PushChar   SimpleExp   PopChar   = e  { Negate(e) } |  '-'   PushChar   SimpleExp   PopChar   = e  { BinExp(IntExp(0),"-",e) } |  PushChar   Apply   PopChar   = a   SimpleExpTail .
SimpleExpTail ::=  BinOp   = o   !   PushChar   SimpleExp   PopChar   = e  { BinExp(a,o,e) } |  <VarRef f2a30> .
CommaSepExps-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   CommaSepExps-Star0   = $tail   Cons  |  Nil .
CompilationUnit ::=  CompilationUnit-Star0   = parserImports   CompilationUnit-Star1   = imports   CompilationBodyExps   = exps   EOF   pState   = s  { CompilationUnit("",imports,exps,s.getSource(),parserImports) }.
BindingTail ::=  BindFun  |  BindValue .
PatternTail ::=  '->'   Name   '('   Pattern   = p   ')'   <VarRef 472aa1> .
DropOp ::=  '<'   <  |  '<='   <=  |  '<>'   <>  |  '='   =  |  '::'   ::  |  ':='   :=  |  '.'   .  |  'and'   and  |  'andthen'   andthen  |  'implies'   implies  |  'or'   or  |  'orelse'   orelse  |  '+'   +  |  '-'   -  |  '*'   *  |  '/'   / .
PairOrElements ::=  '|'   PushChar   Expr   PopChar   = t   '}'  { ConsExp(e,t) } |  PairOrElements-Star0   = es   '}'  { SetExp(l,"Seq",Seq{e | es}) }.
PathExp-Dis0-Star0 ::=  '::'   AName   = $head   PathExp-Dis0-Star0   = $tail   Cons  |  Nil .
Boolp ::=  'true'  { Constp(BoolExp(true)) } |  'false'  { Constp(BoolExp(false)) }.
LetExp ::=  LinePos   = l   'let'   PushChar   Bindings   PopChar   = bindings   LetBody   = body   'end'  { Let(l,bindings,body) }.
TypeExp ::=  TypePath   = path   TypeExp-Dis0  |  '['   PushChar   TypeExp   PopChar   = t   ']'  { ParametricType(Seq{"Seq"},Seq{t}) } |  '{'   PushChar   TypeExp   PopChar   = t   '}'  { ParametricType(Seq{"Set"},Seq{t}) } |  Drop  |  OpType .
Intp ::=  Int   = i  { Constp(IntExp(i)) }.
ImportPath-Star0 ::=  '::'   Name   = $head   ImportPath-Star0   = $tail   Cons  |  Nil .
TypeArgs-Star0 ::=  ','   PushChar   TypeExp   PopChar   = $head   TypeArgs-Star0   = $tail   Cons  |  Nil .
Arrow ::=  '->'   !   ArrowTail  |  <VarRef 2a6ae1> .
Exp1 ::=  PushChar   Exp   PopChar   EOF .
</PRE></TD>
</TABLE>
</HTML>
