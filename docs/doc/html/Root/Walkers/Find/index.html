<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<TITLE>
Find
</TITLE>
</HEAD>
<FONT SIZE="+2"><B>Find</B></FONT><BR><BR><HR>
<FONT SIZE="+1"><B>Overview</B></FONT><BR>
<P>

      An instance of this class can be used to find all element in a given XMF
      value that satisfy the supplied predicate. To use this, construct with a 
      single argument predicate and supply the root of the walk to the 'walk'
      operation. The second argument to 'walk' may be an integer to limit the depth
      of the walk or -1 for no limit.
    
<BR><HR><BR>
<B>Parents</B>
<A HREF="../../../Root/Walkers/Walker/index.html">Walker</A>
,<A HREF="../../../Root/XCore/Object/index.html">Object</A>
,<A HREF="../../../Root/XCore/Element/index.html">Element</A>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructors</B></FONT></TD>
</TR>
<TR><TD>Find(predicate)</TD><TD> No Documentation </TD></TR>
<TR><TD>Find(predicate,duplicates)</TD><TD> No Documentation </TD></TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=3><FONT SIZE="+2">
<B>Attributes</B></FONT></TD>
</TR>
<TR><TD><B>duplicates</B></TD><TD><A HREF="../../../Root/XCore/Boolean/index.html">Boolean<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>predicate</B></TD><TD><A HREF="../../../Root/XCore/Operation/index.html">Operation<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>results</B></TD><TD><A HREF="../../../Root/XCore/Element/index.html">Seq(Element)<A></TD><TD>No Documentation Specified</TD></TR>
<TR>
<TD COLSPAN=3>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../Root/Walkers/Walker/index.html">Walker</A>: refCount, table, visited. <BR><B>From</B> <A HREF="../../../Root/XCore/Element/index.html">Element</A>: roleFiller. <BR></FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="2" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Operations</B></FONT></TD>
</TR>
<TR><TD><B><a href="#addToResults">addToResults</a>(v:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#defaultWalk">defaultWalk</a>(e:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#reWalk">reWalk</a>(v:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#results">results</a>():<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#toString">toString</a>():<A HREF="../../../Root/XCore/String/index.html">String<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walk">walk</a>(element:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkBoolean">walkBoolean</a>(b:<A HREF="../../../Root/XCore/Boolean/index.html">Boolean<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkBuffer">walkBuffer</a>(b:<A HREF="../../../Root/XCore/Buffer/index.html">Buffer<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkInteger">walkInteger</a>(i:<A HREF="../../../Root/XCore/Integer/index.html">Integer<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkNull">walkNull</a>(limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkSeq">walkSeq</a>(s:<A HREF="../../../Root/XCore/Element/index.html">Seq(Element)<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkSet">walkSet</a>(s:<A HREF="../../../Root/XCore/Element/index.html">Set(Element)<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkSlot">walkSlot</a>(o:<A HREF="../../../Root/XCore/Object/index.html">Object<A>,s:<A HREF="../../../Root/XCore/String/index.html">String<A>,value:<A HREF="../../../Root/XCore/Element/index.html">Element<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkString">walkString</a>(s:<A HREF="../../../Root/XCore/String/index.html">String<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkSymbol">walkSymbol</a>(s:<A HREF="../../../Root/XCore/Symbol/index.html">Symbol<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkTable">walkTable</a>(t:<A HREF="../../../Root/XCore/Table/index.html">Table<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B><a href="#walkVector">walkVector</a>(v:<A HREF="../../../Root/XCore/Vector/index.html">Vector<A>,limit:<A HREF="../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR>
<TD COLSPAN=2>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../Root/Walkers/Walker/index.html">Walker</A>: defaultWalk, encounter, encounter, encountered, getRef, initWalker, newRef, reWalk, reset, visited, walk, walkBigInt, walkBoolean, walkBuffer, walkClient, walkCode, walkCodeBox, walkCont, walkDaemon, walkFloat, walkForeignFun, walkForeignObj, walkFun, walkInputChannel, walkInteger, walkNil, walkNull, walkObject, walkOutputChannel, walkSeq, walkSet, walkSlot, walkString, walkSymbol, walkTable, walkThread, walkVector. <BR><B>From</B> <A HREF="../../../Root/XCore/Object/index.html">Object</A>: addDaemon, addDiagramListener, addMissingSlot, addMultiDaemon, addPersistentDaemon, addStructuralFeature, allCompositeValues, allCompositeValuesAndSelf, allDaemonsWithId, allDaemonsWithTarget, applyMapping_client, calcChildrenSlots, changedOnDiagram, compositeValues, daemonNamed, daemonWithId, daemonWithIdAndTarget, daemons, daemonsActive, destroyDaemon, edit, fire, get, getAvailableMappings, getChildren, getChildrenSlots, getChildrenToolTips, getDiagramListenerNamed, getDiagramListeners, getProperties, getProperty, getStructuralFeatureNames, hasDaemonNamed, hasDaemonWithId, hasDaemonWithIdAndTarget, hasDaemonWithTarget, hasProperty, hasSlot, hasStructuralFeature, hotLoad, hotLoaded, ignoreBy, ignoreByAll, init, initSlots, machineInit, nodeEvent, observeBy, observeBy, observedBy, observedBy, oldEdit, orderSequence, orderSequence, propertyTarget, removeDaemon, removeDaemonNamed, removeDaemonsWithId, removeDaemonsWithTarget, removeDiagramListener, removeDiagramListeners, removeStructuralFeature, renameSlot, saveXTO, saveXTOFile, set, setDaemons, setDaemonsActive, setHotLoad, setProperty, showAndLayoutDiagram, showDiagram, slotDenied, slotMissing, slotMissing, slots, synchronise. <BR><B>From</B> <A HREF="../../../Root/XCore/Element/index.html">Element</A>: addTo, allHTMLEntries, allHTMLPackages, assignToGlobal, assignToGlobal, browse, browse_redirect, checkConstraints, copy, copyToClipboard, copyToClipboard_transaction, createDiagram, createDiagramType, createDiagramType, createDiagramType, createTool, cutToClipboard, cutToClipboard_transaction, deleteRecursive, deployXML, die, doc, doubleClick, edit, edit_redirect, equals, error, evaluateExpression, ferror, getChildren, getChildrenToolTips, getDefaultClipboardSource, getDefaultClipboardTarget, graphVizNode, hashCode, init, init, invokeOp, isDeleteProtected, isKindOf, isProtected, isReallyKindOf, isTypeOf, isViewProtected, isWithinNameSpace, labelString, legalNameChangeCheck, legalSlotChangeCheck, legalSlotChangeCheck, lift, nameString, noOperationFound, oclIsKindOf, oclIsTypeOf, of, oldShowDiagram, pasteFromClipboard, populateGraphViz, pprint, pprint, pprint, pprintln, print, println, removeDaemon, removeDaemon, save, save2, selectDiagram, selectModelBrowserNode, send, setDelegation, setOf, setRoleFillerDialog, showAndLayoutDiagram, showDiagram, showModelBrowserNode, slotAffectsLabel, systemId, toHTML, toSVG, toSnapshot, toSnapshot, toString, toType, writeHTML, writeHTML, writeHTMLAllEntries, writeHTMLAllPackages, writeHTMLIndex, writeHTMLOverview, writeXML, writeXMLFile, yield. <BR><TR><TD COLSPAN=2><a name="addToResults"/><FONT FACE="Courier" SIZE="1">@Operation&#160;addToResults[EXTENDER=true](v&#160;:&#160;XCore::Element):XCore::Element<br>&#160;&#160;self.results&#160;:=&#160;self.results-&gt;including(v)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="defaultWalk"/><FONT FACE="Courier" SIZE="1">@Operation&#160;defaultWalk(e&#160;:&#160;Element,limit&#160;:&#160;Element):Element<br>&#160;&#160;null<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="reWalk"/><FONT FACE="Courier" SIZE="1">@Operation&#160;reWalk(v&#160;:&#160;Element,limit&#160;:&#160;Element):Element<br>&#160;&#160;null<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="results"/><FONT FACE="Courier" SIZE="1">@Operation&#160;results():XCore::Element<br>&#160;&#160;results<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="toString"/><FONT FACE="Courier" SIZE="1">@Operation&#160;toString():String<br>&#160;&#160;try<br>&#160;&#160;&#160;&#160;self.of().name.toString()&#160;+&#160;"("&#160;+&#160;if&#160;self.hasSlot("predicate")<br>&#160;&#160;&#160;&#160;then&#160;self.predicate.toString()<br>&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;"predicate"&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;end&#160;&#160;+&#160;","&#160;+&#160;if&#160;self.hasSlot("duplicates")<br>&#160;&#160;&#160;&#160;then&#160;self.duplicates.toString()<br>&#160;&#160;&#160;&#160;else&#160;"NO&#160;SLOT&#160;--&gt;"&#160;+&#160;"duplicates"&#160;+&#160;"&lt;--"<br>&#160;&#160;&#160;&#160;end&#160;&#160;+&#160;")"<br>&#160;&#160;catch(exception)<br>&#160;&#160;&#160;&#160;self.of().name&#160;+&#160;"(Constructor&#160;Error!)"<br>&#160;&#160;end<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walk"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walk(element&#160;:&#160;Element,limit&#160;:&#160;Element):Element<br>&#160;&#160;if&#160;limit&#160;&lt;&gt;&#160;0&#160;and&#160;element&#160;&lt;&gt;&#160;self<br>&#160;&#160;then&#160;<br>&#160;&#160;&#160;&#160;if&#160;predicate(element)<br>&#160;&#160;&#160;&#160;then&#160;if&#160;duplicates<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;self.results&#160;:=&#160;Seq{element&#160;|&#160;results}<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elseif&#160;not&#160;(results-&gt;includes(element))<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;then&#160;self.results&#160;:=&#160;Seq{element&#160;|&#160;results}<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;false<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;end&#160;<br>&#160;&#160;&#160;&#160;else&#160;false<br>&#160;&#160;&#160;&#160;end&#160;;<br>&#160;&#160;&#160;&#160;super(element,limit)<br>&#160;&#160;else&#160;false<br>&#160;&#160;end&#160;<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkBoolean"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkBoolean(b&#160;:&#160;Boolean,limit&#160;:&#160;Element):Element<br>&#160;&#160;null<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkBuffer"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkBuffer(b&#160;:&#160;Buffer,limit&#160;:&#160;Element):Element<br>&#160;&#160;super(b,limit&#160;-&#160;1)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkInteger"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkInteger(i&#160;:&#160;Integer,limit&#160;:&#160;Element):Element<br>&#160;&#160;null<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkNull"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkNull(limit&#160;:&#160;Element):Element<br>&#160;&#160;null<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkSeq"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkSeq(s&#160;:&#160;SeqOfElement,limit&#160;:&#160;Element):Element<br>&#160;&#160;super(s,limit&#160;-&#160;1)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkSet"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkSet(s&#160;:&#160;SetOfElement,limit&#160;:&#160;Element):Element<br>&#160;&#160;super(s,limit&#160;-&#160;1)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkSlot"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkSlot(o&#160;:&#160;Object,s&#160;:&#160;String,value&#160;:&#160;XCore::Element,limit&#160;:&#160;Element):XCore::Element<br>&#160;&#160;super(o,s,value,limit&#160;-&#160;1)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkString"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkString(s&#160;:&#160;String,limit&#160;:&#160;Element):Element<br>&#160;&#160;null<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkSymbol"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkSymbol(s&#160;:&#160;Symbol,limit&#160;:&#160;Element):Element<br>&#160;&#160;null<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkTable"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkTable(t&#160;:&#160;Table,limit&#160;:&#160;Element):Element<br>&#160;&#160;super(t,limit&#160;-&#160;1)<br>end</FONT>
</TD></TR>
<TR><TD COLSPAN=2><a name="walkVector"/><FONT FACE="Courier" SIZE="1">@Operation&#160;walkVector(v&#160;:&#160;Vector,limit&#160;:&#160;Element):Element<br>&#160;&#160;super(v,limit&#160;-&#160;1)<br>end</FONT>
</TD></TR>
</FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Grammar</B></FONT></TD>
</TR>
<TD><PRE>
Find-Dis0 ::=  'limit'   Exp  | { [| 0 - 1 |] }.
SetCmpExp ::=  LinePos   = l   '{'   CommaSepExps   = es   '}'   !  { SetExp(l,"Set",es) } |  LinePos   = l   '{'   Exp   = e   '|'   CmpClause   = c   SetCmpExp-Star0   = cs   '}'  { Comprehensions::Cmp("Set",e,Seq{c | cs}) }.
Find-Dis1 ::=  'duplicates'   Exp  | { [| false |] }.
AddPattern-Dis0 ::=  '+'   AddPattern   = p2  { Addp(p1,p2) } |  <VarRef 298eee> .
Find ::=  Name   = n   'in'   Exp   = v   'when'   Exp   = p   Find-Dis0   = l   Find-Dis1   = d   Find-Dis2   = b   'end'  { [| let walker = Walkers::Find(@Operation anonymous(Drop(Var(n,28)) : XCore::Element):XCore::Element
                 <p>
               end,<d>)
  in walker.walk(<v>,<l>);
     walker.results->collect(Drop(Var(n,30)) |
       <b>)
  end |] }.
BindValue ::=  OptType   = type   '='   SimpleExp   = value  { ValueBinding(name,type,value) }.
Find-Dis2 ::=  'do'   Exp  | { OCL::Var(n) }.
Def ::=  'context'   Def-Dis0   = isForward   ImportPath   = path   PushChar   Exp   PopChar   = exp  { ContextDef(path,exp,isForward) }.
Keywordp ::=  Name   = name   Keywordp-Star0   = names   '['   Keyps   = keys   ']'  { Keywordp(name,names,keys) }.
LocalParserImport-Star0 ::=  '::'   Name   = $head   LocalParserImport-Star0   = $tail   Cons  |  Nil .
SeqCmpExp-Star0 ::=  ','   CmpClause   = $head   SeqCmpExp-Star0   = $tail   Cons  |  Nil .
NonEmptySeqTail ::=  PushChar   Expr   PopChar   = e   PairOrElements .
EvaluationUnit ::=  EvaluationUnit-Star0   EvaluationUnit-Star1   = imports   EvaluationUnit-Star2   = exps   EOF  { Evaluator::EvaluationUnit(imports,exps) }.
Import ::=  PushChar   'import'   ImportPath   = path   ';'  { Import(path) }  PopChar .
Atom ::=  PushChar   VarExp   PopChar   !  |  PushChar   Self   PopChar   !  |  PushChar   StrExp   PopChar   !  |  PushChar   IntExp   PopChar   !  |  PushChar   IfExp   PopChar   !  |  PushChar   BoolExp   PopChar   !  |  PushChar   LetExp   PopChar   !  |  PushChar   CollExp   PopChar   !  |  Parentheses  |  PushChar   Drop   PopChar  |  PushChar   Lift   PopChar  |  PushChar   Throw   PopChar  |  PushChar   Try   PopChar  |  PushChar   ImportIn   PopChar  |  PushChar   FloatExp   PopChar  |  PushChar   LocalParserImport   PopChar  |  PushChar   AtExp   PopChar .
Varp ::=  AName   = name   Varp-Dis0   = pattern   Varp-Dis1   = type  { Varp(name,pattern,type) }.
EvaluationUnit-Star2-Dis0 ::=  Def  |  TopLevelExp .
IfTail ::=  'else'   PushChar   Expr   PopChar   'end'  |  LinePos   = l   'elseif'   PushChar   Expr   PopChar   = e1   'then'   PushChar   Expr   PopChar   = e2   IfTail   = e3  { If(l,e1,e2,e3) } |  'end'  { BoolExp(false) }.
Syntaxp ::=  '[|'   PushChar   Exp   PopChar   = e   '|]'  { Syntaxp(e) }.
AddPattern ::=  AtomicPattern   = p1   AddPattern-Dis0 .
CollMessage ::=  '('   CommaSepExps   = as   ')'  { CollExp(c,n,as) }.
Keyps-Star0 ::=  ','   Keyp   = $head   Keyps-Star0   = $tail   Cons  |  Nil .
PathExp ::=  PushChar   Atom   PopChar   = atom   PathExp-Dis0 .
VarExp ::=  Name   = name   LinePos   = l  { Var(name,l) }.
Parentheses ::=  '('   PushChar   Expr   PopChar   = e   ')'  { Parentheses(e) }.
BindingList ::=  PushChar   Binding   PopChar   = binding   BindingList-Star0   = bindings   <Pair 30df6f> .
CollOp ::=  CollMessage  |  Collect  |  Iterate  | { CollExp(c,n,Seq{}) }.
Objectp ::=  Name   = name   Objectp-Star0   = names   '('   Patterns   = slots   ')'  { Objectp(name,names,slots) }.
Throw ::=  LinePos   = l   'throw'   PushChar   SimpleExp   PopChar   = value  { Throw(l,value) }.
SeqCmpExp ::=  LinePos   = l   '['   CommaSepExps   = es   ']'   !  { SetExp(l,"Seq",es) } |  LinePos   = l   '['   Exp   = e   '|'   CmpClause   = c   SeqCmpExp-Star0   = cs   ']'  { Comprehensions::Cmp(e,Seq{c | cs}) }.
EvaluationUnit-Star2 ::=  EvaluationUnit-Star2-Dis0   = $head   EvaluationUnit-Star2   = $tail   Cons  |  Nil .
Constp ::=  Intp  |  Strp  |  Boolp  |  Expp .
ArrowTail ::=  Name   = n   CollOp   = x   Arrow .
SeqExp ::=  LinePos   = l   'Seq{'   SeqExp-Dis0 .
Exp ::=  PushChar   Expr   PopChar   = e   !  { resolve(order(e)) }.
ArgsTail-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   ArgsTail-Star0   = $tail   Cons  |  Nil .
SetCmpExp-Star0 ::=  ','   CmpClause   = $head   SetCmpExp-Star0   = $tail   Cons  |  Nil .
BindFunArgsTail ::=  Pattern   = p   BindFunArgsTail-Star0   = ps   ')'   <Pair 3c7668>  |  ')'   Seq{} .
KeyArg ::=  Name   = name   '='   PushChar   Expr   PopChar   = exp  { KeyArg(name,exp) }.
Drop ::=  '<'   DropExp   = e   '>'  { Drop(resolve(order(e))) } |  '<|'   Pattern   = p   '|>'  { DropPattern(p) }.
Keyps ::=  Keyp   = key   Keyps-Star0   = keys   <Pair 4e05aa>  |  Seq{} .
Objectp-Star0 ::=  '::'   Name   = $head   Objectp-Star0   = $tail   Cons  |  Nil .
Patterns-Star0 ::=  ','   Pattern   = $head   Patterns-Star0   = $tail   Cons  |  Nil .
LogicalExp ::=  PushChar   SimpleExp   PopChar   = e  { resolve(order(e)) }.
EmptySeqTail ::=  '}'  { SetExp(l,"Seq",Seq{}) }.
ImportPath ::=  Name   = n   ImportPath-Star0   = ns   <Pair 417a27> .
AtExp ::=  LinePos   = l   '@'   PushChar  At  PopChar   = e  { e.setLine(l) }.
Varp-Dis0 ::=  '='   PushChar   Pattern   PopChar  |  null .
Def-Dis0 ::=  '!'  { true } | { false }.
IfExp ::=  LinePos   = l   'if'   PushChar   Expr   PopChar   = e1   'then'   PushChar   Expr   PopChar   = e2   IfTail   = e3  { If(l,e1,e2,e3) }.
Strp ::=  Str   = s  { Constp(StrExp(s)) }.
AName ::=  Name   !  |  Drop .
Collect ::=  '('   AName   = v   '|'   PushChar   Expr   PopChar   = e   ')'  { IterExp(c,n,v,e) }.
Keywordp-Star0 ::=  '::'   Name   = $head   Keywordp-Star0   = $tail   Cons  |  Nil .
Pattern ::=  AddPattern   = p   Pattern-Star0   = es  { es->iterate(e s = p |
  Includingp(s,e)) }  = p   PatternGuard .
Try ::=  LinePos   = l   'try'   PushChar   Expr   PopChar   = body   'catch'   '('   Name   = name   ')'   PushChar   Expr   PopChar   = handler   'end'  { Try(l,body,name,handler) }.
ParserImport ::=  'parserImport'   Name   = name   ParserImport-Star0   = names   ';'   <Pair 47ebc8>  ImportAt { ParserImport(Seq{name} + names,null) }.
Bindings ::=  BindingList  |  Drop .
CollExp ::=  PushChar   SetExp   PopChar   !  |  PushChar   SeqExp   PopChar   !  |  PushChar   SetCmpExp   PopChar   !  |  PushChar   SeqCmpExp   PopChar   ! .
Op ::=  BinOp   !  |  ';'   ; .
TopLevelExp ::=  PushChar   SimpleExp   PopChar   = s   ';'  { resolve(order(s)) }.
SetExp ::=  LinePos   = l   'Set{'   CommaSepExps   = es   '}'  { SetExp(l,"Set",es) }.
EvaluationUnit-Star1 ::=  EImport   = $head   EvaluationUnit-Star1   = $tail   Cons  |  Nil .
Consp ::=  Pairp  |  Seqp  |  Emptyp .
ArgsTail ::=  ')'   Seq{}  |  PushChar   Expr   PopChar   = arg   ArgsTail-Star0   = args   ')'   <Pair 382c19> .
Seqp ::=  'Seq{'   Pattern   = head   SeqpTail   = tail  { Consp(head,tail) }.
Expr ::=  'not'   PushChar   Expr   PopChar   = e  { Negate(e) } |  '-'   PushChar   SimpleExp   PopChar   = e  { BinExp(IntExp(0),"-",e) } |  PushChar   Apply   PopChar   = a   ExpTail .
BindFunArgsTail-Star0 ::=  ','   Pattern   = $head   BindFunArgsTail-Star0   = $tail   Cons  |  Nil .
SeqExp-Dis0 ::=  EmptySeqTail  |  NonEmptySeqTail .
BindFunArgs ::=  '('   BindFunArgsTail .
KeyArgs ::=  '['   KeyArgs-Dis0 .
DropExp ::=  'not'   DropExp   = e  { Negate(e) } |  PushChar   Apply   PopChar   = a   DropExpTail .
Keyp ::=  Name   = name   '='   Pattern   = pattern  { Keyp(name,pattern) }.
PairOrElements-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   PairOrElements-Star0   = $tail   Cons  |  Nil .
Pattern-Star0 ::=  PatternTail   = $head   Pattern-Star0   = $tail   Cons  |  Nil .
LocalParserImport ::=  'parserImport'   Name   = name   LocalParserImport-Star0   = names   <Pair 602bd6>  ImportAt  'in'   PushChar   Expr   PopChar   = e   'end'  { ParserImport(Seq{name | names},e) }.
Emptyp ::=  'Seq{'   '}'  { Constp(SetExp("Seq",Seq{})) } |  'Set{'   '}'  { Constp(SetExp("Set",Seq{})) }.
ImportIn ::=  'import'   ImportPath   = path   'in'   PushChar   Exp   PopChar   = body   'end'  { ImportIn(path,body) }.
AtomicPattern ::=  PushChar   Varp   PopChar  |  PushChar   Constp   PopChar  |  PushChar   Objectp   PopChar  |  PushChar   Consp   PopChar  |  PushChar   Keywordp   PopChar  |  PushChar   Syntaxp   PopChar  |  '('   PushChar   Pattern   PopChar   ')' .
Varp-Dis1 ::=  ':'   PushChar   TypeExp   PopChar  | { NamedType() }.
CompilationUnit-Star0 ::=  ParserImport   = $head   CompilationUnit-Star0   = $tail   Cons  |  Nil .
FloatExp ::=  LinePos   = l   Float   = f  { f.lift().line := l }.
StrExp ::=  LinePos   = l   Str   = e  { StrExp(l,e) }.
Apply ::=  PushChar   Atom   PopChar   = a   ApplyTail   = e   Arrow .
CommaSepExps ::=  PushChar   Expr   PopChar   = e   CommaSepExps-Star0   = es   <Pair 3f74bc>  |  Seq{} .
KeyArgs-Dis0 ::=  ']'   Seq{}  |  KeyArg   = arg   KeyArgs-Dis0-Star0   = args   ']'   <Pair 382db4> .
PatternGuard ::=  'when'   PushChar   Exp   PopChar   = e  { Condp(p,e) } |  <VarRef 3c7407> .
TypePath ::=  Name   = name   TypePath-Star0   = names  { Seq{name | names}->collect(n |
  Symbol(n)) }.
Pairp ::=  'Seq{'   Pattern   = head   '|'   Pattern   = tail   '}'  { Consp(head,tail) }.
BinOp ::=  '<'   <  |  '<='   <=  |  '>'   >  |  '>='   >=  |  '<>'   <>  |  '='   =  |  '::'   ::  |  ':='   :=  |  '.'   .  |  'and'   and  |  'andthen'   andthen  |  'implies'   implies  |  'or'   or  |  'orelse'   orelse  |  '+'   +  |  '-'   -  |  '*'   *  |  '/'   / .
CmpClause ::=  Name   = n   OptType   = t   '<-'   PushChar   Exp   PopChar   = e  { Comprehensions::Bind(n,t.toExp(),e) } |  '?'   PushChar   Exp   PopChar   = e  { Comprehensions::Filter(e) }.
OpType ::=  TypeArgs   = domains   '->'   PushChar   TypeExp   PopChar   = range  { OpType(domains,range) }.
TopLevelCommand ::=  PushChar   SimpleExp   PopChar   = c   pState   = p  { p.consumeToken := false }  ';'  { resolve(order(c)) }.
Self ::=  LinePos   = l   'self'  { Self(l) }.
EvaluationUnit-Star0 ::=  ParserImport   = $head   EvaluationUnit-Star0   = $tail   Cons  |  Nil .
CompilationBodyExps ::=  CompilationBody   = b   !   CompilationBodyExps   = bs   <Pair 417bc3>  |  Seq{} .
Args ::=  '('   ArgsTail .
SeqpTail ::=  ','   Pattern   = head   SeqpTail   = tail  { Consp(head,tail) } |  '}'  { Constp(SetExp("Seq",Seq{})) }.
ExpTail ::=  Op   = o   !   PushChar   Expr   PopChar   = e  { BinExp(a,o,e) } |  <VarRef 3d2015> .
BindingList-Star0 ::=  ';'   PushChar   Binding   PopChar   = $head   BindingList-Star0   = $tail   Cons  |  Nil .
TypeExp-Dis0 ::=  TypeArgs   = args  { ParametricType(path,args) } | { NamedType(path) }.
BindFun ::=  BindFunArgs   = args   OptType   = type   '='   PushChar   SimpleExp   PopChar   = value  { FunBinding(name,args,type,value) }.
Iterate ::=  '('   AName   = v1   AName   = v2   '='   PushChar   Expr   PopChar   = init   '|'   PushChar   Expr   PopChar   = body   ')'  { Iterate(c,v1,v2,init,body) }.
DropExpTail ::=  DropOp   = o   !   DropExp   = e  { BinExp(a,o,e) } |  <VarRef 3f718d> .
LetBody ::=  'in'   PushChar   Expr   PopChar   = body   <VarRef 47953b>  |  PushChar   'then'   PushChar   Bindings   PopChar   = bindings   LetBody   = body  { Let(bindings,body) }  PopChar .
ParserImport-Star0 ::=  '::'   Name   = $head   ParserImport-Star0   = $tail   Cons  |  Nil .
PathExp-Dis0 ::=  '::'   AName   = name   PathExp-Dis0-Star0   = names  { Path(atom,Seq{name | names}) } |  <VarRef 382f45> .
Lift ::=  LinePos   = l   '[|'   PushChar   Exp   PopChar   = e   '|]'  { Lift(l,e) }.
EImport ::=  'import'   TopLevelExp   = exp  { Evaluator::Import(exp) }.
IntExp ::=  LinePos   = l   Int   = e  { IntExp(l,e) }.
Binding ::=  AName   = name   BindingTail .
TypePath-Star0 ::=  '::'   Name   = $head   TypePath-Star0   = $tail   Cons  |  Nil .
CompilationUnit-Star1 ::=  Import   = $head   CompilationUnit-Star1   = $tail   Cons  |  Nil .
Expp ::=  '['   PushChar   Exp   PopChar   = exp   ']'  { Constp(exp) }.
SimpleExpTail ::=  BinOp   = o   !   PushChar   SimpleExp   PopChar   = e  { BinExp(a,o,e) } |  <VarRef f2912> .
ApplyTail ::=  Args   = args   !  { Apply(a,args) } |  KeyArgs   = args   !  { Instantiate(a,args) } |  <VarRef f291a> .
CompilationUnit ::=  CompilationUnit-Star0   = parserImports   CompilationUnit-Star1   = imports   CompilationBodyExps   = exps   EOF   pState   = s  { CompilationUnit("",imports,exps,s.getSource(),parserImports) }.
KeyArgs-Dis0-Star0 ::=  ','   KeyArg   = $head   KeyArgs-Dis0-Star0   = $tail   Cons  |  Nil .
PatternTail ::=  '->'   Name   '('   Pattern   = p   ')'   <VarRef 4600c5> .
TypeArgs ::=  '('   PushChar   TypeExp   PopChar   = arg   TypeArgs-Star0   = args   ')'   <Pair 413c0b> .
PairOrElements ::=  '|'   PushChar   Expr   PopChar   = t   '}'  { ConsExp(e,t) } |  PairOrElements-Star0   = es   '}'  { SetExp(l,"Seq",Seq{e | es}) }.
BoolExp ::=  LinePos   = l   'true'  { BoolExp(l,true) } |  LinePos   = l   'false'  { BoolExp(l,false) }.
Boolp ::=  'true'  { Constp(BoolExp(true)) } |  'false'  { Constp(BoolExp(false)) }.
OptType ::=  ':'   PushChar   TypeExp   PopChar  | { NamedType() }.
TypeExp ::=  TypePath   = path   TypeExp-Dis0  |  '['   PushChar   TypeExp   PopChar   = t   ']'  { ParametricType(Seq{"Seq"},Seq{t}) } |  '{'   PushChar   TypeExp   PopChar   = t   '}'  { ParametricType(Seq{"Set"},Seq{t}) } |  Drop  |  OpType .
Patterns ::=  Pattern   = head   Patterns-Star0   = tail   <Pair 5cea77>  |  Seq{} .
ImportPath-Star0 ::=  '::'   Name   = $head   ImportPath-Star0   = $tail   Cons  |  Nil .
CompilationBody ::=  Def  |  TopLevelExp .
Arrow ::=  '->'   !   ArrowTail  |  <VarRef 298ff4> .
SimpleExp ::=  'not'   PushChar   SimpleExp   PopChar   = e  { Negate(e) } |  '-'   PushChar   SimpleExp   PopChar   = e  { BinExp(IntExp(0),"-",e) } |  PushChar   Apply   PopChar   = a   SimpleExpTail .
Exp1 ::=  PushChar   Exp   PopChar   EOF .
CommaSepExps-Star0 ::=  ','   PushChar   Expr   PopChar   = $head   CommaSepExps-Star0   = $tail   Cons  |  Nil .
TypeArgs-Star0 ::=  ','   PushChar   TypeExp   PopChar   = $head   TypeArgs-Star0   = $tail   Cons  |  Nil .
BindingTail ::=  BindFun  |  BindValue .
Intp ::=  Int   = i  { Constp(IntExp(i)) }.
DropOp ::=  '<'   <  |  '<='   <=  |  '<>'   <>  |  '='   =  |  '::'   ::  |  ':='   :=  |  '.'   .  |  'and'   and  |  'andthen'   andthen  |  'implies'   implies  |  'or'   or  |  'orelse'   orelse  |  '+'   +  |  '-'   -  |  '*'   *  |  '/'   / .
LetExp ::=  LinePos   = l   'let'   PushChar   Bindings   PopChar   = bindings   LetBody   = body   'end'  { Let(l,bindings,body) }.
PathExp-Dis0-Star0 ::=  '::'   AName   = $head   PathExp-Dis0-Star0   = $tail   Cons  |  Nil .
</PRE></TD>
</TABLE>
</HTML>
